=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
*       Crash Bandicoot Disassembly Guide       *
=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

Preface: this guide assumes you have a general understanding of assembly language and the psx hardware. 
It also assumes you have a general understanding of paging, and commonly used data structures such 
as hash tables, linked lists, etc. 

This guide attempts to provide a detailed description of the routines in the Crash binary, and 
analyze the Crash game structure by examining its flow of execution. This will ultimately lead to an 
understanding of the game mechanics and organization of the game's data. 

==============================================
=          SECTION 1: INTRODUCTION           =
==============================================

*****************************
*      Disc Filesystem      *
*****************************

It is important to make a note of the filesystem on the Crash (NTSC) disc before proceeding:

SYSTEM.CNF   -  Disc boot information
SCUS_949.00  -  Crash Bandicoot binary executable
ZBSPTREE.WAD -  Data for binary space partitioning trees
/S0          -  NSD/NSF files in 00-0F range
/S1          -  NSD/NSF files in 10-1F range
/S2          -  NSD/NSF files in 20-2F range
/S3          -  NSD/NSF files in 30-3F range

In the S0-S3 directories are .NSD/.NSF file pairs of the filename S00000**.NSD/.NSF. A significant 
portion of this guide focuses on the format and organization of these files: 

 = NSF files contain all of the necessary data for some 'mode of operation', where each in-game 
   level corresponds to a separate 'mode of operation' (see mode of operation table, listed in 'Main 
   Game Loop' section). This includes graphic models, object code, level organization, collision trees, 
   bsp tree data, and etc. 

 = NSD files contain tables/indexes for their correspondong NSF files. 

After powering on, the system searches for the SYSTEM.CNF file on disc, which upon finding it parses 
and determines the initial executable binary file to load into memory and begin execution. This file 
is SCUS_949.00 for NTSC versions of Crash Bandicoot. The disassembly provides a symbolic 
representation of machine instructions in this binary, including names for subroutines that are 
otherwise unidentified without extensive examination of their content. 

*****************************
* Entry point, main routine *
*****************************
 (Note: due to the PSX's virtual memory architecture, memory addresses in this guide as they appear 
in the disassembly have their MSB set (i.e. the address 0x3E018 is actually accessed as 0x8003E018 
or 0x3E018 + 0x80000000) -this enables the system to cache the requested areas of physical memory 
for faster read/write) 

The entry point for the game is at memory address 0x3E018 in the binary, identified in the 
disassembly as the subroutine 'start'. This sets the location of the global pointer, where all 
global variables are stored, and initializes the heap (*and various other memory initialization 
routines) before executing the routine at 0x11D88, otherwise known as 'main' in the disassembly. 
Other than setting the global pointer, the 'start' routine is seemingly game-independent and it 
should be understood that through this routine the system ends up at 'main'. 

'main' has 3 stages of execution, or consists of 3 subroutines-one for all hardware initialization, 
one for the main game loop, and one for hardware deinitialization. In the binary, these are located 
at 0x1652C, 0x11FC4, and 0x1668C respectively. A flag is set to true/1 at 0x56410 for the main game 
loop conditions prior to execution of these routines. 

The hardware initialization routine at 0x1652C is important because it explains configuration for 
nearly all hardware during game execution. This routine is unfortunately TBD, just understand that 
at some point it reads the filesystem from disc. With the disc's filesystem information, when 
requesting a filename the game can determine at which block of data to begin transferring/paging 
from disc. 

Hardware deinitialization is not the main focus here, so the corresponding routine is also TBD. 

The main game loop is where probably 99% of the remaining instructions are-this is our point of 
interest 

*****************************
* Main game loop:   0x11FC4 *
*****************************

A brief outline of the main game loop routine:

sub_80011FC4(mode):
  
  A) sub_80026140 - Game initialization
  B) sub_80015B58 - Paging and subsystem initialization 	  
  C) sub_80011DD0 - Load entries and/or create processes for main game objects (HUD/display, crash, aku aku, shadows, boxes, fruit)
      	
  MAIN LOOP:
  {
   1) Code for handling a game pause/start button press
   2) If Crash object/process does not exist: 
      A) sub_8002E98C - Create Crash object/process
   3) Code for loading a new level if necessary
   4) Handle pages
      A) sub_800134C8 - handlePages()
   5) Spawn all objects/processes in current zone [for those that have their respawn bit set]
      A) sub_80025928 - spawnObjects()
   6) Update camera
      A) sub_8002EC68 - level dependent routine A
      B) sub_8002EBB4 - level dependent routine B
      C) sub_8002B2BC - cameraUpdate()
   7) Update matrices
      A) sub_80017A14 - updateMatrices(): 
         -recalculate camera translation, rotation, scale, and light matrices
         -load current zone world models/geometry
   8) Render primitives for zone world geometry/models 
      dependent on display mode:
        sub_80019508 - default world model rendering routine
        sub_80019BCC - world model rendering routine variant 1
        sub_80019DE0 - world model rendering routine variant 2
        sub_80019F90 - world model rendering routine variant 3
        sub_8001A0CC - world model rendering routine variant 4
        sub_8001A2E0 - world model rendering routine variant 5
   9) Execute, animate, and render primitives for all objects (includes physics and collision engine)
        sub_8001D5EC - handleObjects()
   10) If current mode is title screen (0x19) then do title screen routine
        sub_800326D8 - title screen routine
   11) Send current primitives to GPU for drawing
        sub_80016E5C - GPU driver/routine
  }

The game has 47 'modes' of execution. Each of these modes correspond to a level in the game, except 
for mode 0x19 which consists of the entire title sequence, main menu, and map. Mode 0x38 is the 
intro sequence, and mode 0x39 is the ending sequence. As discussed above, there exists a pair of 
files S00000**.NSD/.NSF on disc for each mode of execution (or most of them anyway, exceptions 
include mode 00, 02, etc.); these contain the data that will be used by the game in that mode of 
execution. 

Modes of execution
---------
00
01 - Test area (beta)
02
03 - Cortex Power
04 - Cavern level (beta)
05 - Generator Room
06 - Heavy Machinery
07 - Toxic Waste
08 - Pinstripe (Boss 4)
09 - N. Sanity Beach
0A - Papu Papu (Boss 1)
0B - Cliff level (beta)
0C - Jungle Rollers
0D - Waterfall level (beta)
0E - Boulders
0F - Upstream
10 - ??? unknown early beta level 
11 - Hog Wild
12 - The Great Gate
13 - Boulder Dash
14 - Road To Nowhere
15 - Rolling Stones
16 - The High Road
17 - Ripper Roo (Boss 2)
18 - Up The Creek
19 - Main (title sequence, main menu, map)
1A - Native Fortress
1B - Nitrus Brio (Boss 5)
1C - Temple Ruins
1D - Jaws of Darkness
1E - Whole Hog
1F - Dr. Neo Cortex (Boss 6)
20 - The Lost City
21 - Koala Kong (Boss 3)
22 - Stormy Ascent (Inaccessible Level)
23 - Sunset Vista
24 - Bonus Round (Tawna) (different in beta)
25 - Bonus Round (Nitrus Brio; unfinished) (different in beta)
26 - Bonus Round (unknown; unfinished) (different in beta)
27
28 - Lights Out
29 - The Lab
2A - Fumbling In The Dark
2B
2C - The Great Hall
2D - Level Completion Screen
2E - Slippery Climb
2F
30
31
32
33 - Bonus Round (Tawna) (only present in the final version)
34 - Bonus Round (Dr. Neo Cortex; unfinished) (only present in the final version)
35
36
37 - Castle Machinery (only present in the final version)
38 - Intro (only present in the final version)
39 - Ending (only present in the final version)

From the 'main' routine, the main game loop routine (0x11FC4) is passed an argument which is the 
initial mode of execution. This value is undoubtedly 0x19, as the game starts off with the title 
sequence, main menu, and then possibly map if 'a game is started'. 

A) Game initialization

Before anything else, the first thing this routine does is execute the 'game initialization routine' 
located at 0x26140 in the binary. TBD This initializes any variables related to the main game loop. 

B) Paging and subsystem initialization 

After executing the main game initialization routine, the game still has no data to work with: 
nothing from the disc has been loaded into memory other than the currently executing binary. At this 
point the game calls the paging and subsystem initialization routine, located at 0x15B58 in the 
binary. The routine at 0x15B58 accepts 2 parameters: the first being the game mode [of execution], 
and the second a pointer to the location of storage for a 'paging system' structure; the arguments 
in the call are specified as the current mode of execution [passed as the current argument to 
0x11FC4], and a pointer to the destination memory location for the game's 'paging system' 
structure-located at 0x5C528. After execution of 0x15B58, the paging system structure will include 
all the necessary information for paging data-specifically that data located in the NSF file 
corresponding to the current game mode-from disc. The 'Paging and subsystem initialization' section 
focuses on this routine. 

C) Load entries and/or create processes for main game objects (HUD/display, crash, aku aku, shadows, boxes, fruit) 

Once paging has finally been initialized, the appropriate paging routines can be used to load all 
necessary data for the main game objects (HUD/display, crash, aku aku, shadows, boxes, fruit) from 
the NSF file corresponding to the current game mode (i.e. the current NSF file). Most NSF files 
contain the same copy of data for each of these objects, with a few exceptions-for example, the 
great hall does not contain any box objects in its layout, thus the corresponding NSF file does not 
contain the necessary data for the box object and consequently no box objects are spawned in an 
instance of the game on mode 0x2C. The routine located at 0x11DD0 determines, based on the current 
game mode, which main game object data is needed before loading accordingly. 

=MAIN LOOP=

At this point, too little has been discussed to be including a short summary for each of the 
remaining steps in the main loop. The following steps are discussed in their corresponding sections 
of this guide: 

Section 2 - "Paging engine")
  4) Handle pages
      A) sub_800134C8 - handlePages()

Section 3 - "GOOL engine")
   2) If Crash object/process does not exist: 
      A) sub_8002E98C - Create Crash object/process

Section 4 - "Zone and Camera engine")
  3) Code for loading a new level if necessary
  5) Spawn all objects/processes in current zone [for those that have their respawn bit set]
      A) sub_80025928 - spawnObjects()
  6) Update camera
      A) sub_8002EC68 - level dependent routine A
      B) sub_8002EBB4 - level dependent routine B
      C) sub_8002B2BC - cameraUpdate()

Section 5 - "Object engine")
   9) Execute and animate all objects (includes physics and collision engine)
        sub_8001D5EC - handleObjects()

Section 6 - "Graphics and Geometry engine")
  7) Update matrices
    sub_80017A14 - updateMatrices(): 
      -recalculate camera translation, rotation, scale, and light matrices
      -load current zone world models/geometry
  8) Render primitives for zone world geometry/models 
    sub_80019508 - default world model rendering routine
    sub_80019BCC - world model rendering routine variant 1
    sub_80019DE0 - world model rendering routine variant 2
    sub_80019F90 - world model rendering routine variant 3
    sub_8001A0CC - world model rendering routine variant 4
    sub_8001A2E0 - world model rendering routine variant 5
  11) Send current primitives to GPU for drawing
    sub_80016E5C - GPU driver/routine

Section 7 - "Misc")
   1)  Code for handling a game pause/start button press
   10) Title screen routine


==============================================
=          SECTION 2: PAGING ENGINE          =
==============================================
  
***************************************************
* Paging and subsystem initialization:    0x15B58 *
***************************************************

Different parts of paging system initialization deal with separate portions of the paging structure; 
the structure organization will be revealed part by part. 

typedef struct
{
  bool init;                          //0x5C528
  unsigned long mode;                 //0x5C52C
  void **entryHashIndices;            //0x5C530
  hashPair *entryHash;                //0x5C534
  unsigned long ???;                  //0x5C538
  void *levelHeader;                  //0x5C53C
  void *NSD;                          //0x5C540
  unsigned long ???;                  //0x5C544
  unsigned long NSFLocation;          //0x5C548
  unsigned long flag;                 //0x5C54C
  unsigned long physicalPageCount;    //0x5C550
  page physicalPages[22];             //0x5C554
  unsigned long virtualPageCount;     //0x5C91C
  page virtualPages[38];              //0x5C920
  unsigned long pageCount;            //0x5CFA8
  page *currentlyPaging;              //0x5CFAC
  void *itemList;                     //0x5CFB0
  page *mostRecent8;                  //0x5CFB4
  unsigned long CIDPaging;            //0x5CFB8
  page **pageMap;                     //0x5CFBC
} pagingSystem;

typedef struct
{
  bool init;                          //0x5C528
  unsigned long mode;                 //0x5C52C
  ......
  void *NSD;                          //0x5C540
  ......
} pagingSystem;

The paging routine first checks the 'init' flag to see if paging has already been set up, if not 
then it sets the init flag and continue to set up paging. 'mode' is set to the game mode passed in 
the arguments. 

At this point the game determines the corresponding NSD filename for this mode by concatenating 
"S00000", the mode, and ".NSD". In the hardware initialization routine, a filesystem map is created 
at 0x5E03C that maps NSD files to their corresponding sector position on disc and filesize. The game 
now uses 'mode' as an index in to this table, and calls the c malloc routine to allocate space of 
the corresponding filesize and begins reading from disc at the corresponding sector position to the 
newly allocated space. A pointer to this data is saved in the paging structure as 'NSD'. 

typedef struct
{
  unsigned long NSDsize;
  unsigned long NSDlocation;
  unsigned long NSFlocation;
} directoryEntry[n];   //0x5E03C

Since NSD files are just an index for their paired NSF file, the NSF file format must first be understood before understanding NSD. 

typedef struct
{
  chunk_compressed compressedChunks[];
  chunk chunks[];
} nsf;

typedef struct
{
  const unsigned short magic = 0x1235;
  const unsigned short unused = 0;
  unsigned long length;
  unsigned long skip;
  unsigned char data[];
  unsigned char unusedB[skip];
  unsigned char uncompressed[0x10000-length];
} chunk_compressed;

typedef struct
{ 
  const unsigned short magic = 0x1234;
  unsigned short type;
  union
  {
    struct   //for normal chunks
    {
      unsigned long CID;
      unsigned long entryCount;
      unsigned long checksum;
      union
      {
        unsigned long entryOffset[entryCount];
        entry *entryPtr[entryCount];
      }
      entry entries[entryCount];
    }
    struct   //for texture chunks
    {
      unsigned long EID;
      unsigned long entryType = 5;
      unsigned long checksum;
      unsigned char data[0xFFF0];
    }
  }
} chunk;

typedef struct
{
  const unsigned long magic = 0x100FFFF;
  unsigned long EID;
  unsigned long type;
  unsigned long itemCount;
  union
  {
    unsigned long itemOffset[itemCount];
    item *itemPtr[itemCount];
  }
  item items[itemCount];
} entry;

typedef item unsigned char[];

Chunks
--------
The highest level data containers in NSF files are termed 'chunks'. Each chunk is 64kb (0x10000 
bytes) in size, and can be one of 6 types ('type' field): 

  Type 0 = Normal Chunk
  Type 1 = Texture Chunk
  Type 2 = Prototype Sound Chunk
  Type 3 = Sound Chunk
  Type 4 = Wavebank Chunk
  Type 5 = Speech Chunk

Each chunk also has its own unique ID: chunk IDs have been assigned according to their sequence in 
the NSF file; the formula for a Chunk ID (referred to throughout this guide as CID) is:

  '(index << 1) - 1'

or the sequence of odd numbers (which have have their LSB set). The reason for this will be 
explained shortly. **Texture chunks do NOT have their associated precomputed Chunk ID in the CID 
field-it is to be computed later. 

Texture chunks directly describe palette and texture data to be used by models/sprites-the 
difference in structure type is indicated by the union in the chunk structure declaration. The 
format of palette/texture data is to be described later. 

Non-texture chunks are containers for 'entries'-the intermediate level data containers in NSF files. 
==============================================
Entries
---------
Like chunks, entries can be one of many types:

 Type 1  = Object Model/Animation (contains a sequence of multiple models/frames of animation)
 Type 2  = Object Model Vertices  (contains the vertices to be used by Type 1 entries)
 Type 3  = Level Model            (contains a model for some portion of the level)
 Type 4  = Display List           (contains delta encoded display lists describing locality of polygon primitives in sections to be rendered withpainter's algorithm)
 Type 5  = Texture Page           (contains texture/palette data used by models)
 Type 6  = Level Data             (contains initial level settings like Crash's starting location)
 Type 7  = Zone Data              (contains a 'zone': collection of level models to render, objects to spawn, a camera path, collision octree, and misc attributes) 
 Type 11 = GOOL Executable        (contains header, compiled GOOL code, static data, type->state map, execution states, animation sequences/text/sprites/misc for an object process)
 Type 12 = Audio
 Type 13 = MIDI
 Type 14 = Instruments  
 Type 15 = ?
 Type 17 = Music Data
 Type 18 = Palettes for fading sequences
 Type 19 = Demo playback/recorded controls
 Type 20 = Cutscene Models

In addition, entries also have their own unique IDs, but due to the overwhelming number of entries 
that can exist in the chunks of an NSF file the range of possible EIDs (Entry IDs) is much larger 
than CIDs. Unlike CIDs, EIDs are not pre-determined by their sequence-this would be far too vague of 
a descriptor. Instead, EIDs are encoded as 5-character strings: 

0EEEEEEDDDDDDCCCCCCBBBBBBAAAAAA1

where the A, B, C, D, and E bits are the indices of the respective 5 characters in the conversion 
table: 

0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ !

This table, which is used by the game during execution of the EID encoding and decoding routines, is 
located at 0x51728 in the binary. The respective encoding and decoding routines are located at 
0x12660 and 0x126C0 in the binary. 

It is also worth noting that the EID 0x6396347F (which translates to 'NONE!' by the conversion 
table) is used throughout the game to indicate a 'null' EID, however no entry in an NSF file shall 
be identified with this ID. 

Typically the last character in an EID refers to the corresponding entry type; the following table 
is used by the EID decoding routine, which returns the type: 

A = 12
B = 19
C = 11
D = 15
E = 0
F = 0
G = 2
H = 0
I = 16
J = 0
K = 0
L = 6
M = 14
N = 15
O = 0
P = 17
Q = 0
R = 0
S = 4
T = 5
U = 18
V = 1
W = 3
X = 20
Y = 0
Z = 0

Entries are containers for their 'items'-the lowest level data containers in NSF files. Items 
contain the actual significant data that the game engine operates upon, and consist of a majority of 
the game's data. The format of an entries items are entirely dependent on its type: for example, a 
Level Model Entry can have 3 items- the first item is a header for the entire model and describes 
texture data, the second item describes any vertices that might be used by a polygon in the model, 
and the third item describes polygons in the model. Item formats for most entry types are explained 
in this guide. 

--------------------------------------------------------------

The format of NSD files is described below:

typedef struct
{
  unsigned long entryHashOffset[256];
  unsigned long chunkCount;
  unsigned long entryHashCount;
  unsigned long unknownEID;  //0x408
  unsigned long unknownA;    //0x40C
  unsigned long unknownB;    //0x410
  unsigned long unknownC;    //0x414
  unsigned long uncompressedOffset;
  unsigned long compressedCount;
  unsigned long compressedOffsets[64];
  hashPair      entryHash[entryHashCount];
  typedef struct
  {
    const unsigned long magic = ..
    unsigned long levelID;
    unsigned long firstZone;
    unsigned long firstSection;
    unsigned long unknown;
    unsigned long execEIDMap[64];
  } levelHeader;
} NSD;

(this also involves the hashPair structure, a typical key/data pair in a hash table-explained below)
typedef struct
{
  unsigned long EID;
  union
  {
    unsigned long CID;
    entry *entry;
  }
} hashPair;

Now that the NSD file has been loaded into memory, we can record more information for the paging 
system: 

typedef struct
{
  bool init;                          //0x5C528
  unsigned long mode;                 //0x5C52C
  void **entryHashIndices;            //0x5C530
  hashPair *entryHash;                //0x5C534
  ......
  void *levelHeader                   //0x5C53C
  void *NSD;                          //0x5C540
  ......
} pagingSystem;


Level Header and Entry Hash Tables
----------------------------------
At this point, the game records pointers to the 'entryHashOffset' and 'entryHash' arrays from the 
NSD data as 'entryHashIndices' and 'entryHash' respectively in the pagingSystem structure.

The address of 'levelHeader' in the NSD data is also determined by adding 'entryHash'-the preceding 
array-'s size: 'entryHashCount'*sizeof(hashPair) to itself, which is stored under the same name in 
the pagingSystem structure. This is a structure that includes the level's ID (equivalent to game 
mode), the EID of the level's first zone(T7) entry and index of first section within that zone, an 
unknown value, and 'execEIDMap'-a list of EIDs for all GOOL executable entries that exist in the 
corresponding NSF file, indexed by their corresponding in-game object type. 

The array 'entryHashOffset' from the NSD data is a list of relative offsets into the 'entryHash' 
array. The game calculates the corresponding absolute pointers by iterating through the 256 offset 
values and replacing them with &entryHash[entryHashOffset[c]] (where c is an iterator). 
'entryHashIndices' in the paging system structure now points to these newly calculated 
pointers-appropriately titled because these are indexes into a list of key-value pairs, and 
consequently are indexes in a chained hash table: 

                                          
  |----------------------|            |--|--------------------------------------
  | entryHashIndices[0]  |  --------->|  | entryHash[0].EID | entryHash[0].CID |
  |----------------------|             -- --------------------------------------
                                      |--|--------------------------------------
                                      |  | entryHash[1].EID | entryHash[1].CID |
                                       -- --------------------------------------
                                       ..............
  
  |----------------------|            |--|--------------------------------------
  | entryHashIndices[1]  |  --------->|  | entryHash[n].EID | entryHash[n].CID |
  |----------------------|             -- --------------------------------------
                                      
  |----------------------|            |--|------------------------------------------          
  | entryHashIndices[2]  |  --------->|  | entryHash[n+1].EID | entryHash[n+1].CID |         
  |----------------------|             -- ------------------------------------------
  
  ............
  
  |----------------------|            |--|--------------------------------------    
  | entryHashIndices[255]|  --------->|  | entryHash[z].EID | entryHash[z].CID |                                          
  |----------------------|             -- --------------------------------------

  
The purpose of this chained hash table is to resolve something significant (value) given an EID 
(key). An EID is the ID of an entry from the NSF file. The keys in the hashPair array consist of 
all possible EIDs of entries from the corresponding NSF file, and their significant paired values are 
initially the CIDs of the chunk that contains them. Eventually, the game will need to resolve a CID 
from an EID-it accomplishes this with the hash table by: 

  1) calculating the hash of the EID with the hash function: (EID << 15) & 0xFF
  2) using this as an index into the 'entryHashIndices' pointer array to grab the correct pointer
  3) starting the search for the pair with key/EID at the pointed index
  4) returning the accompanying value/CID for the pair upon finding a match

The reason for resolving the CID is so that only the corresponding chunk (of data) can be paged from
the NSF file on disc into memory. The desired chunk of data containing the entry with the requested
EID will then lie in memory for the game to handle further. This is generally what the paging system
wishes to accomplish, but its overall function is a little more complex

NSF File
---------
At this point the game also uses 'mode' as an index into the filesystem map at 0x5E03C to determine 
the sector location of the current NSF file, and records this in 'NSFLocation' of the paging 
structure. 
 
Page Map
---------
typedef struct
{
  bool init;                          //0x5C528
  unsigned long mode;                 //0x5C52C
  void **entryHashIndices;            //0x5C530
  hashPair *entryHash;                //0x5C534
  ......
  void *levelHeader;                  //0x5C53C
  void *NSD;                          //0x5C540
  ......
  unsigned long NSFLocation           //0x5C548
  ......
  page **pageMap;                     //0x5CFBC
} pagingSystem;

At this point the game allocates space for 'chunkCount' (from the NSD data) pointers to 'page' 
structures with malloc, storing a pointer to the newly allocated space in 'pageMap' of the 
pagingSystem structure. These pointers are initialized with the value 0xFFFFFFEE, a constant that 
the game identifies as the 'null page' pointer. 

(This map, indexed by 'chunk index' of chunks in the NSF file [chunk index = (CID >> 1)], will
eventually be used to map chunks to their associated page structures.)

Subsystem pre-initialization
-----------------------------
Next, the game pre-initializes all 21 of its 'subsystems', which are very crucial to the game's 
operation. Each subsystem handles a different aspect of the game's function. Referring back to entry 
types:

Subsystem/ 
Entry Type         Entry description            Subsystem ID 
*   0        n/a                                   *NONE
    1        Object Model/Animation                 SVTX
    2        Object Model Vertices                  TGEO
    3        Level Model                            WGEO 
    4        BSP Tree Display List                  SLST
    5        Texture Page                           TPAG
    6        Level Data                             LDAT
    7        Zone Data                              ZDAT
*   8        n/a                                   *CPAT
*   9        n/a                                   *BINF
*   10       n/a                                   *OPAT
    11       GOOL Executable                        GOOL
    12       Audio                                  ADIO
    13       MIDI                                   MIDI
    14       Instruments                            INST
    15       ?                                      IMAG
*   16       n/a                                   *LINK
    17       Raw Audio (or is it Map Data???)       MDAT                             
    18       Palettes for fading sequences          IPAL
    19       Demo playback/recorded controls        PBAK
    20       Cutscene Models                        CVTX

A majority of the game's subsystems deal with separate initialization/memory allocation, 
destruction/freeing, and entry independent routines for future routines in the game that will handle 
entries of their respective type. An array of jumptables for each subsystem is located at 0x514DC in 
the binary, having the following format: 

struct
{
  char id[4];
  unsigned long pad;
  void (*initA)();
  void (*initB)();
  void (*handleEntry)(entry*);
  void (*killA)();
  void (*killB)();
} subsystemTables[21];

The 'initA' routines are called for all 21 subsystems during pre-initialization, 'initB' during 
post-initialization, 'handleEntry' when handling an entry of that subsystem type, 'killA' and 
'killB' during de-initialization TBD. Note that the id field/'Subsystem ID' 4 character strings are 
present in the binary as the acronyms in the above list. Official subsystem names have been proposed 
but are currently unknown. Some subsystems do not have a corresponding entry type, or entries of 
that type do not actually exist (types with an asterisk in the table above). 

Page Allocation and Initialization
----------------------------------
Here we allocate physical memory for and initialize a number of 'physical' and 'virtual' page 
structures; these structures are the game's means of reading data from the NSF file. 

Before we move on it is important to understand the distinction between the page -structure- and the 
physical -page- of memory that will be allocated to it. 

typedef struct
{
  unsigned char *data;
  ......
} page;

A physical page of memory is 64kb (0x10000 bytes) in size. At this point, the game attempts to 
allocate space for at most 22 physical pages (0x10000 * 22 bytes) of memory-if there is not enough 
space then it continues trying for 21 pages, 20, and so on. 

typedef struct
{
  bool init;                          //0x5C528
  unsigned long mode;                 //0x5C52C
  void **entryHashIndices;            //0x5C530
  hashPair *entryHash;                //0x5C534
  ......
  void *levelHeader                   //0x5C53C
  void *NSD;                          //0x5C540
  ......
  unsigned long physicalPageCount;    //0x5C550
  page physicalPages[22];             //0x5C554
  unsigned long virtualPageCount;     //0x5C91C
  page virtualPages[38];              //0x5C920
  unsigned long pageCount;            //0x5CFA8
  ......
  page **pageMap;                     //0x5CFBC
} pagingSystem;

The resulting count of physical pages that were allocated are stored in 'physicalPageCount'. The 
game then initializes that many of the reserved/statically allocated physical page -structures- 
('physicalPages' in the pagingSystem structure) which includes pointing each page structure's 'data' 
field to its own contiguous 64kb physical page of memory from the group that was just allocated. 

After initialization, each physical page structure will refer to its own 64kb physical page of 
memory; each of the referenced physical pages will eventually be used to hold/page-in some 64kb 
chunk from the NSF file. 

typedef struct
{
  unsigned char *data;
  unsigned short state;
  unsigned short rw;
  unsigned short index;
  unsigned short requests;
  ......
} page;

In addition to determining the location of the physical page for the 'data' field, initialization 
for each physical page structure also involves appropriately initializing the 'state', 'rw', 
'index', and 'requests' fields: 

- 'state'    is set to 1; this is the initial state for the page [structure] and indicates that
  the page is a clean, blank slate page.
- 'rw'       is set to 1; this is the read/write mode for the page and determines (page replacement?-look at src again)
- 'index'    is set to the index of the physical page allocated to the page structure
- 'requests' is set to 0; this indicates the number of unprocessed requests to read from that page

The game then sets 'virtualPageCount' to 38, and initializes all 38 reserved virtual page structures 
('virtualPages' in the pagingSystem structure). These are initialized differently from physical 
pages: 

- 'data'     is set to 0; this indicates that the page does not reference a physical page of memory,
   and is consequently a virtual page
- 'rw'       is set to 0; (this indicates some sort of difference for page replacement due to being virtual)
- 'index'    is set to 0; this field is unused and therefore zeroed because the index of a physical
page is irrelevant when no physical page has been allocated for this (virtual) page

When all pages have been allocated and initialized, the game writes to standard output a debug 
string consisting of a confirmation message followed by the number of physical pages allocated 
(i.e. printf("Inited and Allocated %d pages\n", NSD.physicalPageCount); ) 

Texture and Wavebank Page Initialization
----------------------------------------

At this point the game initializes 16 'Texture Pages' and 8 'Wavebank Pages'. These differ from normal
physical pages in that the memory they reference is not located in main memory-but in either video or
sound hardware.

TBD

***************************************************************************************

Now that paging has been initialized, the game can page data in the NSF file from disc. As discussed 
briefly in the preceding section, the game specifies this in terms of the EID of the entry that 
contains the data to be paged-that is, if the game wants to access a unit of related data/entry 
(GOOL Executable, Zone Data, Level Model, etc), the paging system must: 

- lookup/resolve the CID of the chunk in the NSF file on disc that contains the entry with specified 
  EID using the entry hash table 
- if a physical page does not already exist for this chunk then
  - seek the disc to the location of the chunk
  - read 64kb chunk from disc to a blank physical page
  - associate that physical page with the chunk by recording it's CID in the respective field of the page structure
- locate the entry with specified EID in the physical page with the chunk of interest
- rewrite the data field of the hash pair for that EID (currently contains the CID of container/parent 
  chunk) with a pointer to the entry; future lookups of that EID will return a direct pointer to the 
  entry rather than a CID only to redundantly repeat the above 

The next section looks at these operations and the heart of the paging system in more detail.

*********************
* The Paging System *
*********************

     lookupEntry
         |
      pageEntry
       /    \
handlePages--newPage
     |        |
 handlePage allocatePage
              |
             freePage

------------------------------------------------------
| Entry lookup/lookupEntry(EID or hashPair): 0x15A98 |
------------------------------------------------------

The first routine to consider is the one that resolves the accompanying value for a specfied EID 
from the entry hash table, further processing that value for the purpose of eventually resolving a 
pointer to the associated entries' data. The routine accepts either an EID, or a pointer to a 
hashPair (a pair in the entry hash table) as an argument. EIDs are discerned from [hashPair] 
pointers by having their least significant bit (i.e. rightmost, bit 1) set. 

  |----------------------|            |--|--------------------------------------
  | entryHashIndices[0]  |  --------->|  | entryHash[0].EID | entryHash[0].CID |
  |----------------------|             -- --------------------------------------
                                      |--|--------------------------------------
                                      |  | entryHash[1].EID | entryHash[1].CID |
                                       -- --------------------------------------
                                       ..............
  
  |----------------------|            |--|--------------------------------------
  | entryHashIndices[1]  |  --------->|  | entryHash[n].EID | entryHash[n].CID |
  |----------------------|             -- --------------------------------------
                                      |--|------------------------------------------          
                                      |  | entryHash[n+1].EID | entryHash[n+1].CID |         
                                       -- ------------------------------------------
                                       ...............

  |----------------------|            |--|--------------------------------------          
  | entryHashIndices[2]  |  --------->|  | entryHash[m].EID | entryHash[m].CID |         
  |----------------------|             -- --------------------------------------
  
  
  ............
  
  |----------------------|            |--|--------------------------------------    
  | entryHashIndices[255]|  --------->|  | entryHash[z].EID | entryHash[z].CID |                                          
  |----------------------|             -- --------------------------------------

1) Locate the hash pair of interest:

  If the argument specified is an EID, then the following steps are performed to locate the hash pair:

    1) calculating the hash of the EID with the hash function: *(EID >> 15) & 0xFF
    2) using this as an index into the 'entryHashIndices' pointer array to grab the correct pointer
    3) starting the search for the pair with key/EID at the pointed index
    4) returning a pointer to the found pair (hashPair pointer) 

    (*in the binary this is actually calculated as ((EID >> 13) & 0x3FC) since it is necessary that
      the byte offset of the 'entry hash index pointer' relative to the start of the array is used
      in calculating the resultant address of that element)
  
  Otherwise, the (pointer to the) hash pair of interest is the argument specified to the routine.

2) Does the pair indicate that its corresponding entry has been paged?

   -If the accompanying value in the pair is a CID (indicated like EIDs with the LSB set), then 
    it is the CID of the chunk containing the entry with the EID in the key field-indicating that 
    this chunk is still to be paged from the NSF file on disc into its own physical page in memory 
    and that the corresponding entry is to be located in that page and resolved of its pointer.

    The 'pageEntry' routine accepts 2 arguments: a reference to the CID of a chunk to be paged, and 
    a reference to the EID of an entry to be located within the paged chunk and resolved of its 
    pointer. The referenced CID in the first argument is eventually replaced with a resolved pointer 
    to the 'paged' entry.

    Given the accompanying value in the pair is a CID, the game calls the pageEntry routine with 
    arguments as references to the EID key and CID value from the pair. The routine then directly 
    replaces the referenced CID value in the pair with the resolved pointer to the paged entry. 

   -If the accompanying value in the pair is an entry [pointer] then the entry and its chunk have
    already been paged, and can be located by that pointer.

3) Return the pointer to the entry
    
-----------------------------------------------
| Paging entries/pageEntry(EID, CID): 0x14C08 |
-----------------------------------------------

As discussed above, 'paging' an entry actually refers to the process of paging the -chunk- that 
contains the entry to a physical page in main memory. 

The 'pageEntry' routine accepts 2 arguments: a reference to the CID of a chunk to be paged, and a 
reference to the EID of an entry to be located within the paged chunk and resolved of its pointer. 
(The referenced CID in the first argument is eventually replaced with a resolved pointer to the 
'paged' entry. EDIT: happens much deeper in handlechunkentries?) 

It must be noted that a chunk should not need to be paged if it already exists in some physical page 
in main memory, implying that a physical page is already associated with or 'mapped' to that chunk. 
Recall that chunks are to be mapped to their associated physical page [structures] through the 
'pageMap' array as they are paged (*the pageMap array is indexed by the 'indexes' of its mapped 
chunks, where 'chunk index = (chunk CID >> 1)'). At initialization, the pageMap array is zeroed with 
'null page' pointers -indicated by the value 0xFFFFFFEE. Thus, after initialization, no chunk has 
yet been mapped to a physical page and consequently no chunk has yet been paged from disc. However, 
once a chunk is paged from disc, a physical page will have been 'created' to contain the chunk's 
data and a pointer to that page will have been recorded at the appropriate index in the pageMap 
array. 

The pageEntry routine performs the following:

  1) -locating a physical page that has already paged the specified chunk (with the pageMap array)
     -OR 'creating' a new physical page that will eventually page/hold the paged chunk; this
      includes mapping the specified chunk to the new page in the pageMap array
  2) 'handling' specific pages, including most importantly the page that will eventually hold or 
      currently holds the chunk; this pages the actual chunk data to page if it is new
  3) returning the [now 'handled'] page containing the chunk


1) Create or reuse:

This routine begins with checking the pageMap array at the index of the chunk to be paged:
  
  -if this is a null page pointer (0xFFFFFFEE) then the chunk has not yet been paged:
    - 'create' a single physical page with the 'page_new' routine; this page will be
      used to page the chunk data from disc. 
      * creating the page also involves mapping the specified chunk in the pageMap array
    - if page creation failed then return error

  -otherwise, the page with the requested chunk [data] already exists at that index:
    - if the page's read mode is 'reuse', then it is [re]used to provide the chunk 
      data; pages are not handled
    - if the page's read mode is 'reuse & note entry', then it is [re]used to provide
      the chunk data but the EID of the entry to be accessed/located within the chunk
      also replaces the page's associated EID. pages are not handled if the page is at
      a state of 0x14
    - if the page's read mode is 'copy on read', then instead of reusing the page a 
      new physical page is created as a copy-just as if the chunk hadn't yet been paged,
      this page will be used to page the chunk data from disc.

2) Handling Pages
    
'Page handling' in this case refers to a separate routine that performs operations for specific 
pages based on their current 'states'-it is through this routine that the chunk data is paged to its 
respective page. If a page's state is set to 'starting to page', as is the case when a new physical 
page is 'created', the page handling routine will begin to page that pages' associated chunk's data 
from disc. 

The page handling routine can operate exclusively based on the CID of a chunk given as its argument. 
The page handling routine handles all existing/non-blank pages-but pages in certain states will 
'break' if they aren't associated with CID given in the argument; thus, a group of pages in the same 
state, for some states, may operate exclusively for the page associated with the chunk with given 
CID. 

From the pageEntry routine, the 'handlePages' routine is called with the CID of the chunk that is to 
be paged-therefore it will operate exclusively for the page that was created or reused in step 1). 
This is described in more detail further below. 

3) Returning the page

A pointer to the now handled page is returned.

-----------------------------------------------------------------
| Creating a Page/newPage(page, CID, EID, count, flag): 0x146F0 |
-----------------------------------------------------------------

'newPage' is a multipurpose routine that can be used to either 'create' a new physical page 
structure or copy a specified number of non-contiguous physical page structures to a group of new, 
contiguous physical page structures. Physical page [structure] 'creation' consists of allocating a 
blank physical page [structure] from the physicalPages array (recall that mode = 1 indicates a 
blank/clean-slate page), populating it with the necessary information, and setting it into a state 
where it can begin paging. 

The routine accepts 5 arguments: the location of a source page to copy if copying is desired (if 
this is null/0 then a single page will be created), the CID of the chunk whose data is to be paged 
to the new page, the EID of the entry that will be accessed within that chunk's data, a reference to 
the number/count of contiguous chunks in relation to the chunk associated with the source page whose 
associated pages are to be copied in a contiguous arrangement, and an unused flag. 

'newPage' begins by allocating 'count' physical page(s) [structures] with the 'allocatePage' 
routine; this routine returns the index of the -last- physical page [structure] in the first group 
of 'count' contiguous blank physical page(s) [structures] that could be located [the index of the 
first blank physical page [structure] that could be located if count = 1]. The reason for returning 
the index of the last physical page rather than the first in the group is explained further below. 

typedef struct
{
  unsigned char *data;
  unsigned short state;
  unsigned short rw;
  unsigned short index;
  unsigned short requests;
  unsigned short savedLen;
  unsigned short compressed;
  unsigned char *data_ext;
  unsigned long CID;
  unsigned long EID;
  unsigned long groupLen;
  hashPair *pair;
  page *tail;
  unsigned long timestamp;
} page;

The routine then checks for the existence of a source page argument; if this is specified as 0 or 
null, then the following is done to populate the single blank physical page [structure] at the index 
returned by allocatePage: 

- the 'CID' field is set to the CID of the chunk whose data is to be paged by this page 
- the 'EID' field is set to the EID of the entry that will be accessed within that page
- the 'requests' field is set to 0 as no additional reads have been requested
- a timestamp is recorded in the 'timestamp' field, indicating this pages instance of creation
- the 'groupLen' field is set to 1, indicating that 1x32 (64kb) sectors worth of data will be read 
  when paging the associated chunk data for this page 
- the 'tail' field is set to point to the page itself; this field is used when a page is part of 
  some grouping of contiguous pages and it is set to point to the last page in that group 
- the 'state' field is set to 'starting to page' = 2

- 'pageCount' in the paging system structure is incremented, for a single page has been created
- the chunk for this page is mapped to the page in the pageMap array
- return a pointer to the page

Otherwise a source page [structure] has been specified and there possibly exists a number of 
additional, likely non-contiguous, pages whose associated chunks are those 'count' contiguous chunks 
in relation to the chunk associated with the source page [structure] and therefore (the pages) must 
be copied to a contiguous arrangement to comply with that of their associated chunks: 

(fig x?: given source page 'pageI', since following pages pageJ and pageK refer to non-contiguous 
 chunks on disc, copy/rearrange the count=3 pages to refer to contiguous chunks)
 
         source pages                                     destination pages
         BEFORE COPY:                                        AFTER COPY:
pageI-->pageJ-->pageK                               pageI-->pageJ-->pageK                               
  |       |      |                                    |       |      |
CID 19 CID 23  CID 21                               CID 19 CID 21  CID 23
  |       |      V                                    |       |      V
  |       |   |-----|                                 |       |   |-----|  
  |       |   |     |                                 |       |   |     |
  |       V   |   <-+----------|                      |       V   |   <-+-----------------\
  |    |-----||-----|          |                      |    |-----||-----|                 |
  |    |     |                 |                      |    |     |                        |
  V    |   <-+-----------------|------\               V    |   <-+-----------------\      |
|-----||-----|                 |      |             |-----||-----|                 |      |
|     |                        |      |             |     |                        |      |
|   <-+------------------\     |      |             |   <-+------------------\     |      |
|-----|                  |     |      |             |-----|                  |     |      | 
                         |     |      |                                      |     |      |
   ____                  |     |      |                ____                  |     |      |
  / __ \                 |     |      |               / __ \                 |     |      |
 | /  \ |                |     |      |              | /  \ |                |     |      |
 | \__/ | ------> ... chunkI chunkJ chunkK ...       | \__/ | ------> ... chunkI chunkJ chunkK ...
  \____/      (pageMap[9] pageMap[10] pageMap[11])    \____/      (pageMap[9] pageMap[10] pageMap[11]) 
                    

Then the following is done in performing the copy:

- the index of the first 'source chunk' is determined as the index of the chunk associated with the 
  source page [structure] using the page's CID field (index = CID >> 1) 
- the index of the last 'source chunk' is determined by adding 'count-1' to the index of the first 
  chunk, yielding the index of the chunk at 'count-1' chunks ahead of the source chunk 

- starting with the -last- source chunk as the current source chunk and working -backwards- until the 
  first source chunk, also working backwards thru the 'count' allocated physical pages or 'destination 
  pages' (starting with the last and ending with the first) as the current destination page: 

  - the current 'source page' is determined by looking up the page associated with the current
    source chunk with the pageMap array
  - copy the CID, EID, requests, and timestamp from the source page to the destination page
  - rewrite the 'EID' field in the destination page if the EID specified in the routine args
    is not the EID 'NONE!'
  - rewrite the 'groupLen' field in the destination page with the number of pages being copied
    to the destination (i.e. 'count')
  - point the 'tail' field in the destination page to the -last- destination page
  - if the current destination page is the last then set the 'state' field to 'ready to page'
    otherwise set the 'state' field to (0xC = ?)

- return a pointer to the first destination page

The new arrangement of structures suggests that these and other page structures can be part of 
their own 'groups':

(fig. x2
 = All page structures in a group refer to the last page structure in the group through 
 the 'tail' field. 
 = All page structures in a group also have the number of page structures in the group in the 
 'groupLen' field.
 = The last page structure in a new group is set to the 'ready to page' state = 2; others set 
  to state 0xC.
 = All page structures in a group refer to contiguous source chunks that are to be paged from 
   disc to their contiguous physical destination pages.)

 -------------------------------------
 |  Field    | pageI   pageJ   pageK |
 ---------------|-------|------------|            
 | .tail     |  \-------\--------^   |
 | .state    | 0xC     0xC        2  |
 | .CID      | 19       21       23  |
 | .groupLen |  3        3        3  |
 -------------------------------------


----------------------------------------------------------
| Allocating Page(s)/allocatePage(count, flag):  0x141F4 |
----------------------------------------------------------

It must be noted that the operation of this routine entails something entirely different from the 
'page allocation' that occurs during paging system initialization. When the paging system is 
initialized, the actual physical pages or 64kb blocks of memory are 'allocated' with the malloc 
function before being created references to in their respective physical page structures. Each 
physical page structure is then initialized as a blank, clean-slate page structure. When the game 
wishes to use physical page structures to page chunk data from disc to their respective pages, it 
must first 'create' those page structures; creating physical page structures involves first locating 
the desired number of contiguous blank physical page structures and then changing their states and 
data members to reflect that those page structures will be 'in use' and thus no longer blank or 
'free'. The process of locating these contiguous blank page structures is the 'page allocation' in 
question and is therefore the operation of this routine. 

The allocatePage routine accepts two arguments: a reference to the 'count' of contiguous physical 
page structures to allocate and a seemingly unused flag. The value referenced by 'count' is 
eventually replaced with the actual number of physical page structures allocated by the routine. 

This routine simply iterates through all physical page structures and finds a group of 'count' 
contiguous physical page structures that are either blank/free OR 'not in use'. As will be discussed 
in the page handling section, a physical page structure is deemed 'not in use' when it is in the 
'paged' state (i.e. state 0x14 or 0x15) and there are currently no remaining 'requests' to read from 
its associated page. If more than one group of 'count' contiguous page structures is found that meet 
the requirements, then the group with the lowest sum of timestamps is used; thus, this routine 
locates the overall earliest created group of 'count' blank or unused contiguous physical page 
structures. 

If a group of 'count' contiguous blank or unused page structures could not be found, then the next 
smallest possible group is tried. If no blank or unused page structures could be found, the routine 
returns error. 

The routine then 'frees' each page structure in the group, for there may exist some page structures 
in the group that are unused and not yet freed as they ought to be. This involves calling the 
'freePage' routine for each page structure in the group; as will be discussed in the next section, 
the freePage routine does more than just simply change the state of a page structure to blank/free. 

Finally the routine replaces the value referenced by the 'count' argument with the number of 
physical page structures actually allocated, and returns the index of the first physical page 
structure in the allocated group. 

-------------------------------------------
| Freeing Page(s)/freePage(page): 0x1331C |
-------------------------------------------

The 'freePage' routine accepts a single argument: a pointer to a physical page structure to free.

The process of freeing a physical page structure consists of the following steps:

  If the page structure is in the 'paged' state (state 0x14 or 0x15), indicating that a chunk has 
  already successfully been paged to its page:

  1) For the chunk contained in the physical page associated with the page structure: if the chunk 
     contains entries (i.e. is a non-texture or audio-type chunk), then for each entry within the 
     chunk:

     - Locate the hashPair for this entry by searching for its EID in the entry hash table
     - Use this entry's type field to call the appropriate 'killA()' routine in the subsystem table
       for entries of that type using the entry as the argument; this performs any additional 
       type-specific deallocation operations for that entry
     - Replace the accompanying entry pointer in the hashPair with the CID associated with the
       page structure (i.e. the CID of the chunk contained in the physical page associated with
       the page structure); this indicates that the entry no longer exists in memory as the page
       associated with the chunk that contains it is being freed. Subsequent lookups of the 
       entry's EID will then result in a re-paging of the parent chunk's data.

  2) Replace the pointer at the index of (CID >> 1) in the pageMap array with the null page pointer,
     where CID is the CID associated with the page structure; this indicates that the chunk with
     that CID no longer exists in some page of physical memory and is no longer associated with any 
     page structure.

  3) Set the state of the physical page structure to 'free'/'blank' and return success

  Otherwise, the page structure is in some other state, in which case its state is set to 
  'free'/'blank' and the routine returns success.

------------------------------------------------------
| Handling Pages and misc./handlePages(CID): 0x134C8 |
------------------------------------------------------

The 'handlePages' routine is essentially the core of the paging system; this routine determines 
which of the existing physical page structures need to be handled, before handling them with the 
'handlePage' routine. The 'handlePage' routine performs operations for these pages based on their 
current states-for example, free, paging, polling, and paged are a few common page states. 

This routine accepts one argument: the CID of a chunk whos associated page structure is to be 
handled exclusively. The page handling routine can operate exclusively based on the CID of a chunk 
given as its argument. The page handling routine handles all existing/non-blank pages-but pages in 
certain states will 'break' if they aren't associated with CID given in the argument; thus, a group 
of pages in the same state, for some states, may operate exclusively for the page associated with 
the chunk with given CID. If this routine is specified as -1, then all pages 

INCOMPLETE
........

--------------------------------------------------
| Handling a Page/handlePage(page, CID): 0x13D48 |
--------------------------------------------------

TODO: routine description


typedef struct
{
  bool init;                          //0x5C528
  unsigned long mode;                 //0x5C52C
  void **entryHashIndices;            //0x5C530
  hashPair *entryHash;                //0x5C534
  ......
  void *levelHeader                   //0x5C53C
  void *NSD;                          //0x5C540
  ......
  unsigned long physicalPageCount;    //0x5C550
  page physicalPages[22];             //0x5C554
  unsigned long virtualPageCount;     //0x5C91C
  page virtualPages[38];              //0x5C920
  unsigned long pageCount;            //0x5CFA8
  page *currentlyPaging;              //0x5CFAC
  ......
  
  page **pageMap;                     //0x5CFBC
} pagingSystem;

---
Before continuing it must be made clear that chunks can exist as one of 2 separate formats in the 
NSF file on disc: uncompressed (RAW) chunks, or compressed chunks. As the 'handlePage' routine pages 
chunk data from the NSF file on disc to the destination page or group of physical pages, it may 
additionally need to 'expand' or decompress that data to a valid uncompressed (RAW) format, 
effectively fitting the the entirety of the destination page or group of physical pages. 

All possible chunks in the NSF file (indexed from 0 to 'chunkCount' in the NSD structure) already 
exist as uncompressed chunks; additionally, there exists a compressed copy for each of the first 
'compressedCount' chunks. Although this is redundant in terms of storage, there can be somewhat of a 
performance gain by paging a group of compressed chunks rather than their uncompressed counterparts. 


Uncompressed chunks
-------------------
Uncompressed chunks have a fixed length of 32 sectors. A sector is the smallest addressable unit of 
data on (mode 1) CD-ROMs, and is consequently the maximum amount of data that can be read in a 
single read from disc to the psxes CD-ROM controller's read buffer. Sectors are 2048 bytes in size. 
The proper unit conversion calculations show that: 

  32 sectors/uncompressed chunk * 2048 bytes/sector = 64kb/uncompressed chunk. 

Naturally, uncompressed chunks are read by reading 32 sectors directly from their location on disc 
to their associated 64kb physical page of memory with the appropriate library routines. Since page 
structures in a group refer to a number of contiguous physical destination pages and contiguous 
source chunks on disc, then each of the source chunks in a group can be paged [in a single read] 
from the NSF file on disc to the destination pages by determining the sector location of the chunk 
associated with the first page structure in the group, seeking to that location, and reading 
'groupLen' * 32 SECTORS to the destination location of the physical page ('data' field) associated 
with the first page structure: 

(fig x.2: reading 4 contiguous chunks to the contiguous destination pages of their associated group of 
          4 page structures. )


pageA   pageB  pageC   pageD
  |       |      |       |
  |.data  |.data |.data  |.data
  V       V      V       V
|------|------|------|------|
|      |      |      |      |
|      |      |      |      |
|------|------|------|------|
    ^
    |
    \------------------\
   ____                |
  / __ \          /----|--------------------------\
 | /  \ |        |  |------|------|------|------|  |          
 | \__/ | ------>|  |chunkA|chunkB|chunkC|chunkD|  |  
  \____/         |  |      |      |      |      |  |          
(seeked to sector|  |------|------|------|------|.................
   location of    \-------------------------------/ 
     chunkA) (pageMap[0] pageMap[1] pageMap[2] pageMap[3])
 
As illustrated above, by reading 4 chunks of data at the location of chunkA-the chunk associated 
with the first page structure in the group, pageA-not only is the data from chunkA itself read but 
also the data from the 3 following contiguous chunks. By reading this data as a whole-which is more 
than a chunk or physical page worth-to the destination physical page-the page associated with the 
first page structure in the group, pageA-it is filled in its entirety with the data from chunkA, and 
the data from chunkB begins to overflow into the contiguously following memory region for pageB's 
physical page, continuing in the same trend for pageC and pageD. 

The 'uncompressedOffset' field from the NSD structure (i.e. location 0x418 in the NSD file) gives 
the sector location of the first uncompressed chunk in the NSF file. Since all uncompressed chunks 
are 32 sectors in length and stored contiguously in the NSF file, the following calculation is used 
to determine the sector location of an uncompressed chunk with index C: uncompressedOffset + (C * 
32). 

Compressed chunks
-----------------
Compressed chunks have an arbitrary length of sectors; they are naturally smaller in size than 
uncompressed chunks. After paging compressed chunks to their respective pages, when the 
decompression routine is called on the page structures associated with those pages, each compressed 
chunk will be decompressed to an uncompressed chunk-thus expanding to fit all 32 sectors of its 
page. 

Before reading a compressed chunk, its sector location and length in sectors must be determined; 
this is not a linear calculation like with uncompressed chunks-which have a fixed length. The 
'compressedOffsets' array from the NSD structure contains 4 byte structures, indexed by chunk index, 
that describe the sector location and length in sectors of each compressed chunk in the NSF file; 
these structures have the following format: 

  OOOOOOOO OOOOOOOO OOOOOOOO OOLLLLLL

  O = sector location of compressed chunk
  L = length of compressed chunk (in sectors) 

Thus, a compressed chunk of length L (in sectors) has 'saved' (32 - L) sectors of data with its 
compression; this is the difference in length of the chunk when uncompressed (always 32) and when 
compressed (L). For a group of 'i' compressed chunks, where L is the sum of lengths in sectors of 
all chunks in the group, ((i*32) - L) sectors of data have been saved by their compression. 

Each of the source chunks in a group of compressed chunks can be paged [in a single read] from the 
NSF file on disc to the destination pages by determining the sector location of the chunk associated 
with the first page structure in the group, seeking to that location, and reading L SECTORS to the 
appropriate destination location. The appropriate destination location is NOT that of the physical 
page associated with the first page structure in the group (such as when paging uncompressed pages): 

(fig x3: paging 3 consecutive compressed chunks to the beginning of their group of associated 
         physical pages and failing to decompress properly
         a portion of chunkB is lost after expanding chunkA)
         
 Paging 3 consecutive compressed chunks   
 
    pageA      pageB        pageC  
     |           |           |       
     |.data      |.data      |.data               
     V           V           V                 Attempting to decompress their data...
|-----------|-----------|-----------|
|   chunkA  |chunkB(2/3)|chunkC(1/3)|            pageA      pageB        pageC  
|           |           |           |             |           |           |       
|chunkB(1/3)|chunkC(2/3)|    empty  |             |.data      |.data      |.data      
|-----------|-----------|-----------|             V           V           V        
    ^                                        |-----------|-----------|-----------|
    |                                        |    /\     |chunkB(2/3)|chunkC(1/3)|  
    \------------------\                     |  chunkA   |    ???    |           |
   ____                |                     |    \/     |chunkC(2/3)|    empty  | 
  / __ \          /----|---------------\     |-----------|-----------|-----------|
 | /  \ |        |  |-----|----|-----|  |                   X FAIL X    
 | \__/ | ------>|  |chnkA|cnkB|chhkC|  |
  \____/         |  |     |    |     |  |      
(seeked to sector|  |-----|----|-----|.................
   location of    \--------------------/ 
     chunkA) (pageMap[0] pageMap[1] pageMap[2] pageMap[3])

By paging the contiguous compressed chunks to the beginning of the physical page associated with the 
first page structure in the group, the entirety of the first compressed chunk and a portion of the 
second compressed chunk are able to fit within the first physical page-but after decompression, the 
first chunk is expanded to fit the entirety of that page, effectively overwriting part of the second 
compressed chunk. Thus, data is lost and the second chunk cannot be properly decompressed without 
all of its data intact. 

However, if an optimal amount of empty physical page space is skipped after the first physical page 
in the group to yield a new destination such that when paging the chunks would still fit within the 
group's physical pages, then when chunks are decompressed sequentially, no chunk that remains 
compressed should exist to be replaced by expansion in the destination physical page. 

(fig x4: paging 3 consecutive compressed chunks to the optimal destination in their group of 
         associated physical pages and succeeding to decompress properly;
         chunkB replaces part of chunkA in expansion, but this occurs after chunkA has been
         decompressed at which point it is unneeded. The same relationship exists between
         chunkB and chunkC.)
         
 Paging 3 consecutive compressed chunks   
 
    pageA      pageB        pageC  
     |           |           |       
     |.data      |.data      |.data               
     V           V           V                 Attempting to decompress their data...
|-----------|-----------|-----------|
|   empty   |chunkA(2/3)|chunkB(1/3)|            pageA      pageB        pageC  
|   ^skipped|           |           |             |           |           |       
|chunkA(1/3)|chunkB(2/3)|   chunkC  |             |.data      |.data      |.data      
|^----------|-----------|-----------|             V           V           V        
 |                                           |-----------|-----------|-----------|
 |                                           |    /\     |     /\    |    /\     |  
 \---------------------\                     |  chunkA   |   chunkB  |  chunkC   |
   ____                |                     |    \/     |     \/    |    \/     | 
  / __ \          /----|---------------\     |-----------|-----------|-----------|
 | /  \ |        |  |-----|----|-----|  |                      
 | \__/ | ------>|  |chnkA|cnkB|chhkC|  |   
  \____/         |  |     |    |     |  | 
(seeked to sector|  |-----|----|-----|.................
   location of    \--------------------/ 
     chunkA) (pageMap[0] pageMap[1] pageMap[2] pageMap[3])

As it turns out, this 'optimal amount' of empty physical page space skipped is the total amount of 
sectors of data saved by the group's compression-'savedLen'. 


state 2 - 'ready to page'
-------------------------

At this state, the page structure is ready to begin transferring it's associated chunk's data from 
the NSF file on disc to its physical page of memory. If the page structure is part of its own group 
of structures, then the contiguous chunks associated with each page structure in the group will be 
paged [in a single read] from the NSF file on disc to their [group of contiguous] physical pages. 

When the handlePage routine is called with a page structure on this state, the 'currentlyPaging' 
pointer from the pagingSystem structure is checked for existence; if this pointer refers to a valid 
page structure then some page structure is currently already paging data from disc-in which case the 
routine aborts its operation by returning error, for the current page structure cannot be paged 
until I/O for the currently paging structure has finished. Otherwise, if the pointer is 0, then the 
routine will proceed. 

--
At this point, a bound check is performed for the page structure [in terms of its 'group'] when the 
routine is not operating in global mode. This verifies that the CID of the structure's associated 
chunk falls between the CID of the page's group's head structure's chunk and the CID of the page's 
group's tail structure's chunk. 

 ------------------------------------------------------------------
 |  Field    | pageA  .... .... pageN pageM .......... pageZ       |
 ---------------|----------------|-----|---------------------------             
 | .tail     |  \----------------\-----\----------------^          |
 |           |                                                     |
 | .CID      | (a*2)|1        (n*2)|1 (m*2)|1   (a+(groupLen*2))|1 |
 |           |                                                     |
 | .groupLen | (z-a)           (z-a)   (z-a)          (z-a)        |
 -------------------------------------------------------------------

Since every page structure in some group points to the last page structure in the group through the 
'tail' field and knows the length of the group it belongs to through the 'groupLen' field, then for 
some page N that belongs to a group of pages with indexes in the range of a-z, the respective CIDs 
of chunks associated with the head and tail pages of the group can be found with the following: 

  tail: refer to page in 'tail' field, the CID of this page is the CID of the chunk associated with the tail page
  head: CID of chunk associated with tail page - (groupLen*2)

In performing the bound check for the page structure, the routine calculates the CIDs of chunks 
associated with the respective head and tail pages of the page structure's group and determines if 
the CID of the chunk associated with the page structure falls within that CID range. If the CID is 
valid, then the routine will proceed. 

-- 

The routine then remembers the CID of the chunk associated with the page structure, a chunk that 
will soon be paged from disc, in 'CIDPaging' of the pagingSystem structure. 

It is worth noting that at this point, if paging is disabled (gp[0x14]), then the routine will 
delete the current page before aborting its operation by returning error. Additionally, when the 
routine is in global mode, if the disc is currently busy (determined by polling with the library 
routine CD_Sync), then the routine will abort its operation by returning error. 


The routine then calls the 'setupDecompressPage' routine, a multi-purpose routine that when used in 
the current context, determines whether the chunk(s) associated with the group that the current page 
structure belongs to are compressed or uncompressed; for those groups that are compressed, for each 
page structure in the group that the current page structure belongs to: the routine calculates the 
length (in sectors) of the space saved by the group of compressed chunks starting with the page 
structure's associated chunk and ending with the group's tail structure's associated chunk, 
recording the computed length in the 'savedLen' field of the page structure (most importantly, for 
the first page structure in the group, this calculates the length (in sectors) of the space saved 
by the entire group of compressed chunks associated with page structures in the group). In this 
context, the 'setupDecompressPage' routine also changes the state of the last page structure in the 
group to 'paging=3' and the state of all other page structures in the group to 'paging[for non-tail 
pages]=13'. (Note that, although states are changed at this point, including the state of the 
current page structure, when returning to the 'handlePages' routine operations still must be 
completed for the previous state). In this context the 'setupDecompressPage' routine returns the 
index of the first page structure in the group that the current page structure belongs to; this 
returned index is then used to locate the first page structure in the group, whose data members are 
needed for calculating the source, length, and destination parameters for reading the entire group 
of associated chunks from disc to physical memory. 

At this point the routine records a pointer to the current page structure in 'currentlyPaging' of 
the pagingSystem structure-this indicates that the page structure 'currentlyPaging' and the group of 
page structures that it belongs to are considered to be currently paging. 

Before paging or reading from disc, the routine must calculate the source sector location on disc, 
length (in sectors) of the read, and destination memory location for the read. For either 
uncompressed or compressed groups of page structures, the read is done starting at the sector 
location of the chunk associated with the first page in the group, from the current NSF file. 
However, a group of compressed chunks have variable length and can not be written directly to the 
first associated page in the group, whereas a group of uncompressed chunks have a fixed length and 
are written directly to the first associated page in the group. Separate calculations are performed, 
then, for compressed page structure/chunk groups and uncompressed page structure/chunk groups to 
determine the appropriate source and destination locations and lengths. Thus, the routine determines 
its next course of action by checking the 'compressed' flag of the current page structure, 
indicating whether it belongs to a group of compressed or uncompressed structures: 

 = For uncompressed page structure/chunk groups =
  - Source location: the 'uncompressedOffset' field from the NSD structure (i.e. location 0x418 in the 
    NSD file) gives the sector location of the first uncompressed chunk in the NSF file. Since all 
    uncompressed chunks are 32 sectors in length and stored contiguously in the NSF file, the following 
    calculation is used to determine the sector location of an uncompressed chunk with index C: 
    uncompressedOffset + (C * 32). Thus, the source location is the sector location of the uncompressed 
    chunk associated with the first page structure in the group-the chunk that has index = (CID >> 1), 
    where CID is the CID of the chunk associated with the first page structure in the group, as recorded 
    in the first page structure's CID field. 

  - Length: all uncompressed chunks are 32 sectors in length. Since a group of page structures has the 
    number of pages or the count of associated chunks recorded in the 'groupLen' field of each page 
    structure belonging to the group, then to read a group of 'groupLen' contiguous uncompressed chunks 
    to their associated groupLen pages requires groupLen * 32 sectors of data to be read 

  - Destination location: the destination of the read is to the physical page associated with the 
    first page structure in the group (pointed to by its .data field)-it will be filled in its entirety 
    with the newly paged data from the chunk associated with the first page structure in the group, and 
    the data from the chunk associated with the second page structure in the group will begin to 
    overflow into the contiguously following memory region (i.e. the physical page associated with the 
    second page structure in the group); this continues in the same trend for any remaining chunks 
    associated with the read. 

  * srcLocationRel = NSD.uncompressedOffset + ((pageA.CID >> 1) * 32);
  * srcLength      = pageA.groupLen * 32; 
  * dstLocation    = pageA.data;

 = For Compressed page structure/chunk groups =
  - Source location: the 'compressedOffsets' array from the NSD structure is an array of 4 byte 
    structures describing the sector locations and lengths (in sectors) of each compressed chunk in the 
    NSF file; the structures in the array are indexed by the index of the compressed chunk that they 
    describe. Thus, the source location for the read is the sector location of the compressed chunk 
    associated with the first page structure in the group-the chunk that has index = (CID >> 1), where 
    CID is the CID of the chunk associated with the first page structure in the group, as recorded in 
    the first page structure's CID field. 

  - Length: compressed chunks are of variable length. The sum of the lengths (in sectors) of each 
    compressed chunk in a group yields the total number of sectors that need to be read to read that 
    entire group. Recall that the space saved (in sectors) by an entire group of compressed chunks has 
    been recorded in the 'savedLen' field of the first page structure in their associated group, 
    calculated with the following: "For a group of 'groupLen' compressed chunks, where L is the sum of 
    lengths in sectors of all chunks in the group, ((groupLen*32) - L) sectors of data have been saved 
    by their compression." Since '((groupLen*32) - L) = savedLen' sectors have been saved by the group's 
    compression, then '(groupLen*32) - savedLen = (groupLen*32) - ((groupLen*32) - L) = L' is the sum of 
    lengths in sectors of all chunks in the group. Thus, (groupLen*32) - savedLen sectors of data are 
    required to be read for reading the entire group of compressed chunks, where 'groupLen' and 
    'savedLen' are those sector counts recorded in the first page structure of the associated group. 

  - Destination location: recall that when reading a group of compressed chunks, they must be read to 
    the destination located at 'savedLen' sectors [worth of physical memory] -after- the physical page 
    associated with [or data field of] the first page structure in their associated group, thereby 
    avoiding the potential overwrite of not-yet-decompressed chunks during the sequential decompression 
    process (where 'savedLen' is that field of the first page structure in the group, i.e. the total 
    number of sectors saved by the group's compression). Therefore the destination location is located 
    "2048 bytes/sector * 'savedLen' sectors" bytes -after- the physical page associated with the first 
    page structure in the associated group of page structures. 

  * srcLocationRel = NSD.compressedOffsets[(pageA.CID >> 1)] >> 6;
  * srcLength      = (pageA.savedLen*32) - pageA.groupLen;
  * dstLocation    = &pageA.data[(pageA.savedLen * 2048)];
 
Note that sector locations in the NSD structure/file are given relative to the sector location of 
the NSF file on disc. This location was recorded as 'NSFLocation' in the pagingSystem structure 
during initialization. Thus, to calculate the absolute sector location on disc the relative location 
is added to the location of the NSF file on disc. 

The routine then calls the following sequence of CD-Rom library functions to initiate the transfer 
process: 

  srcLocation = NSFLocation + srcLocationRel;  //calculate absolute sector location of chunk(s) on disc
  CDIntToPos(srcLocation, &CDPosition);        //convert this location to absolute CD position 
  CDControlF(2, &CDPosition);                  //seek the disc to this position
  CDReadB(srcLength, dstLocation, 0x80);       //read 'srcLength' sectors of disc data to dstLocation in physical mem

At this point the routine has completed its operation for the current page structure's 'ready to 
page' state, which has in process changed to either of the 'paging' states (in the 
'setupDecompressPage' routine). The routine continues by handling the current page structure in its 
new state. 

state 3 - 'paging'
------------------
A page structure in the 'paging' state has already initiated a CD-Rom read/transfer and is now 
waiting for that transfer to complete. Only one page structure should be in this state at a time; if 
a page structure is in this state and is not the currently paging page structure, as recorded in 
'currentlyPaging' of the paging system, then the page structure is deleted and 'currentlyPaging' is 
set to 0. 

When the currently paging structure is handled at this state, in global mode, the routine simply 
polls for the paging /transfer/read operation completion; if the read operation is still in progress 
the routine will return. When not in global mode, the routine will halt/suspend execution until the 
paging/transfer/read operation is complete. The status of the read operation is determined by 
calling the 'CdReadSync' CD-Rom library function with the 'mode' parameter as 'determine current 
status and promptly return' (i.e. poll) OR 'wait for completion'. 


The rest of page structure states and the paging system is TBD    

 state | description
--------------------
   1   | free/blank page
   2   | ready to page
   3   | paging
   4   | successfully paged entries/ready to init page entries
  10   | ready to write to spu
  11   | writing to spu
  12   | ready to page [for non-tail pages in a group]
  13   | paging [for non-tail pages in a group]
  20   | successfully paged and entries inited
  21   | ???
  30   | initing page entries


==============================================
=          SECTION 3: GOOL ENGINE            =
==============================================


Engine overview
---------------

The GOOL engine is quite possibly the heart of the entire Crash game. 

All objects in the Crash game are instances of some GOOL executable; a GOOL executable is an entry 
that includes all the necessary data to describe the functionality or application of a particular 
type of game object. A GOOL executable entry includes a header/metadata, compiled object code, 
static variable data, state information, an event/subtype map, and animation descriptors for its 
particular type of game object. When the game wishes to create an object, it first specifies a 
source GOOL executable, and an object is created as an -instance- of that executable-much like how a 
process is created in relation to its source executable in an operating system. For this reason, the 
terms 'object' and 'process' are used interchangeably throughout this guide; both terms refer to the 
same concept. Probably the most important part of a GOOL executable is the compiled object code, or 
compiled GOOL bytecode; the compiled GOOL bytecode of an executable that any given object is an 
instance of-or more simply the bytecode for that object-will be 'interpreted' by the GOOL bytecode 
interpreter routine. The GOOL bytecode interpreter routine will then operate based on the 
instructions it sees in the bytecode for that object. 


Objects
-------
The structure of game objects is described below. The following sections will focus on data members 
in the object structure in order of relevance. 

typedef struct
{ 
  unsigned long type;    //0x0
  unsigned long subtype?; //0x4
  cbound bound;          //0x8
  entry *global;         //0x20
  entry *external;       //0x24
  entry *zone;           //0x28
  unsigned long state;   //0x2C
  ccolors colors;        //0x30
  typedef struct
  {
    object *self;
    object *parent;
    object *sibling;
    object *children;
    object *creator;
    object *player;
    object *collider;
    object *invoker;
  
    cvectors vectors;
  
    unsigned long statusA;       //0xC8
    unsigned long statusB;       //0xCC
    unsigned long statusC;       //0xD0
    unsigned long subtype;       //0xD4
    unsigned long PIDflags;      //0xD8 (PID in left 3 bytes, flags in right byte)
    unsigned long *sp;           //0xDC
    unsigned long *pc;           //0xE0
    unsigned long *fp;           //0xE4
    unsigned long *transBlock;   //0xE8 
    unsigned long *eventBlock;   //0xEC
    unsigned long *headBlock;    //0xF0
  
    union                        //0xF4
    {
      bool miscFlag;
      object *miscChild;
      entry *miscEntry;
    };
  
    unsigned long F8;
    
    unsigned long aniStamp;
    unsigned long initStamp;
    unsigned long aniCounter;
    unsigned char *aniSeq;
    unsigned long aniFrame;
  
    unsigned char *entity;
    signed long pathProgress;
    unsigned long pathCountEtc;  //num of paths in left 3 bytes, right byte unknown
    unsigned long floor;
    unsigned long stateFlags;
    signed long speed;
    unsigned long displayMode;
    unsigned long _12C;
    unsigned long hitGroundStamp;
    signed long hitGroundVelocity;
    unsigned long zIndex;   
    unsigned long event;  //0x13C
    signed long camZoom;
    unsigned long approachYZ;
    signed long hotspotClip;
    unsigned long _14C;
    unsigned long _150;  
    unsigned long _154;
    unsigned long memory[0x41];

  } process;      //0x60
} object;  

sizeof(object) = 604;

 ------------------------------------------------------------------
| Object/process allocation & initialization *OPAT initA: 0x1AAD8 |
 ------------------------------------------------------------------

Recall that during subsystem initialization, the 'initA()' routines for each respective subsystem 
are called, where instances of structures associated with those subsystems are allocated and 
initialized. For instance, the initA routine for the 'OPAT' subsystem is located at 0x1AAD8 in the 
binary; this routine simply allocates memory for all game objects/processes and initializes them 
accordingly. Thus 'Object/Process Allocation Table' is the proposed name for the OPAT subsystem 
acronym. 

The following memory locations are reserved for instances of structures related to game objects:

namespace GOOL
{
unsigned long levelStates[3592];  //0x5E348
unsigned long states[304];        //0x5FF58
object *player;                   //0x60DB0
object *objects;                  //0x60DB4
sobject groups[8];                //0x60DB8
sobject free;                     //0x60DF8
object *current;                  //0x60E00
unsigned long objectCount;        //0x60E04
spacePair spaceMap[28];           //0x60E08
unsigned long spaceCount;         //0x61888
...
}

The routine begins by allocating memory for 96 objects with the malloc function (96 objects * 604 
bytes/object = 57984 bytes). A pointer to the newly allocated memory is stored at 0x60DB4, or the 
'objects' pointer in the namespace. Then, semantically, the 'objects' pointer refers to a 
dynamically allocated array of 96 objects. Eventually, the second object in the array is pointed to 
in the 'sibling' field of the first object and the third object is pointed to in the 'sibling' field 
of the second object; this continues in the same trend for the remaining objects such that all 96 
objects can be followed as a linked list through their sibling fields. 

The routine then allocates a separate section of memory for the 97th object-the player object. An 
extra 256 bytes in addition to the standard 608 byte structure size (608+256 = 860) is allocated for 
the player object-eventually it will be seen that the player, Crash, needs this additional memory 
due to its natural need for more activation record instances and therefore a larger stack size than 
normal objects. A pointer to the newly allocated memory is stored at 0x60DB0, or the 'player' 
pointer in the namespace. 

If either the memory for the objects or for the player object could not be allocated, the routine 
returns error (0xFFFFFFF1). 

At this point, all the necessary memory for objects has been allocated. The routine then initializes 
each object object or sets up a 'hierarchical organization' among these objects. Before discussing 
the specifics of the object initialization process, a brief overview of game object organization is 
necessary: 

--Object organization--

typedef struct
{ 
  unsigned long type;    //0x0
  ...
  typedef struct
  {
    object *self;        //0x60
    object *parent;      //0x64
    object *sibling;     //0x68
    object *children;    //0x6C
    ...
  } process;      //0x60
} object;  

Objects in the game, much like processes in an operating system, are organized and grouped 
hierarchically-that is, each object has a 'parent' object which includes the object among its [group 
of] 'children': 

           free<-+----------------+---------------------------------------------------------          
            |    \                 \                   \                \                   \
 .children  |    | .parent         | .parent           | .parent        | .parent           |
            |    |                 |                   |                |                   |
            V    |   .sibling      |      .sibling     |                |       .sibling    |          
          objects[0]---------->objects[1]---------->objects[2]......objects[94]---------->objects[95]
             |
  .children  | null              ...                  ....              ...                   ...
             |                
             V
             X

The illustration above shows the organization of objects after the initialization and set up steps; 
semantically, the illustration displays the 96 objects as belonging to the 'group' of 'free 
objects'. Notice that the following is true for objects in the 'group' (starting with object[0] and 
ending with object[95]): 

  1) each object points to its succeeding object thru its 'sibling' field 
     - a group of objects can be followed as a linked list through their 'sibling' fields: the first thing 
       necessary in establishing a group of objects is for all objects belonging to the 'group' (except the 
       last) to point to their following objects thru their sibling fields-the last/rightmost object in a 
       group shall then have a null pointer in its sibling field. 

  2) each [linked] object points to its parent object [in this case, a special object referred to as the 
     'free object'] thru its 'parent' field 
     - objects belonging to the same group point to the same 'parent' object through their 'parent' 
       fields-thus, all objects in some group are 'owned' by the same parent object and consequently 
       compose the group of 'children' objects that belong to that parent object. The parent object of a 
       group of [children] objects determines the specifics of the objects in that group and ultimately 
       defines its own sub-hierarchy. (for example, the group of [children] objects belonging to the 'free' 
       object consists of all clean, free/blank slate objects). Thus, the second thing necessary in 
       establishing a group of objects is for all objects belonging to the group to point to the same 
       parent object in their 'parent' fields. 

  3) the parent object of the group (ex. the 'free object') points to the first object in the group 
     (object[0]) thru its 'children' field 
     - the 'children' field of a group's parent object always points to the first object in the group: the 
       third thing necessary in establishing a group of objects is for the group's parent object to point 
       to the group's first object in its 'children' field. 

An object can be a number of different 'types' (TODO: better name); an object's type indicates 
either its existence or that the object is a 'head object'. An object's type is indicated and 
defined in it's 'type' field: 


Object Types
---------------------------------
 Type | Purpose
---------------------------------
  0   | Unused/free/blank-slate
  1   | In use
  2   | Head object
---------------------------------

Type 0:        free) The object is currently not in use by the game and currently does not 'exist'; it is available/free for the game to use/instantiate as an instance of a new object, then deeming it as 'in use'; all unused/free/blank-slate objects must have the 'free object' as a parent, thus belonging to the group of 'free objects'.
Type 1:      in use) The object is currently in use by the game and currently 'exists' 
Type 2: head object) The object is a head object

Type 2 objects, more commonly referred to as 'head' or root objects, are special objects in the 
game. Head objects are of the highest hierarchical rank and they are the only objects in the game 
that do not have a parent object. As it turns out, head objects have an entirely different structure 
from normal objects-that is they include only their 'type' field (which is, naturally, always 2) and 
a 'children' field. 

typedef struct
{
  unsigned long type;
  object *children;
} sobject;

Therefore, head objects technically do not 'exist' as objects in the game but are rather only 
containers for objects and their sub-hierarchies/families of objects. The game has a total of 9 head 
objects: the 'free' object [whose children compose the group of free objects] and 8 root 'group' 
objects (indicated as the 'groups[]' object array in the namespace). Eventually, it will be seen 
that once a game object is instantiated, it will belong to or have as an ancestor one of the 8 root 
'group' objects; thus, these root group objects are 'categories' for existing, 
second-highest-ranking, game objects: 

Root group objects
----------------------------
root group object | purpose 
----------------------------
   groups[0]      | TBD
   groups[1]      | TBD
   groups[2]      | TBD 
   groups[3]      | TBD
   groups[4]      | TBD
   groups[5]      | TBD
   groups[6]      | TBD
   groups[7]      | TBD
---------------------------

-----------------------------

The initialization process consists of the following steps:

  1) For the free object:
      -set 'type' field to 2 (indicates the object is a head object)
      -set 'children' field to point to object[0] (thus object[0] will be the first free object)
  2) For each of the 96 objects:
     - set 'type' field to 0 (indicates the object is free/unused)
     - set 'sibling' field to point to the following object if not the last object (defines the group 
       organization) 
       (objects[n].process.sibling = &objects[n+1];)
       else set 'sibling' field to 0 (last object does not have a sibling and thus marks the end of the group)
     - set 'parent' field to point to the free object
       (objects[n].process.parent = free;)
     - set 'children' field to 0
  3) For the 8 root group objects:
     -set 'type' field to 2 (indicates the object is a head object)
     -set 'children' field to 0 (no objects belong to the root groups at initialization)
  4) For the player object:
     -set 'type' field to 0 (indicates the player object is free/unused)
     -set 'parent' field to 0 
      (instantiation for the player object is done separately from normal objects; i.e. the player object 
      does not belong to and is not an object among the 'pool' of free objects, since its instantiation 
      does not involve grabbing an arbitrary free object from the pool, and an instance of the player 
      object will always exist in the 860 byte region allocated for it; thus it is not necessary for the 
      player object to belong to any group and therefore have a parent at initialization) 
     -set 'sibling' field to 0 (player is additionally not part of any group at initialization and therefore does not 
      have a sibling; it is not among the group free objects)
     -set 'children' field to 0

TODO: player object init separate

--------------------------------

Before giving a brief overview of the algorithms, it is necessary to understand several terms that will be used:

- Any object [other than the first] in a group of more than one object has a 'directly preceding 
  object'; An object X that has some object Y as its sibling is said to 'directly precede' Y in its 
  organization-thus, object Y's directly preceding object is object X 

- Any object [other than the last] in a group of more than one object has a 'directly proceeding 
  object'; An object Y is said to 'directly proceed' some object X when object X has object Y as its 
  sibling-thus object X's directly proceeding object is object Y 

- The process of 'following an object's sibling links' refers to dereferencing an object's sibling 
  object pointer to dereference the object's sibling object's sibling object pointer to dereference 
  the object's sibling object's sibling object's sibling object pointer and so on until either a 
  desired object [pointer] is reached or an object pointer has been dereferenced to yield the last 
  object in its group, thus the object's sibling pointer is null and cannot be dereferenced and does 
  not refer to an object that has another sibling pointer that can be dereferenced and so on. All 
  sibling objects that have been dereferenced in this process are said to have been 'followed'. 

- Every desired object Y in a group that can be reached only by following an object X's sibling links 
  is said to proceed object X in its organization 

- Every object X in a group whose sibling links can be followed to reach a desired object Y is said to 
  precede object Y in its organization 

-----------------------------------------------------------------------------
| Object/process reorganization algorithms: various sections of inline code |
-----------------------------------------------------------------------------

When an object/process is created/instantiated, a free object is first 'removed' from the group or 
'pool' of free objects and then 'added' to one of the 8 root groups (i.e. one of the 8 root group 
object's group of children). Since the object has been removed from the group of free objects and 
now belongs to one of the 8 root groups, the object's type is changed to 'in use' to reflect that it 
is now an existing object and can then be instantiated. The object creation/instantiation process 
will be discussed in the next section; this process involves the adding and removing of objects 
to/from groups. This section discusses the object add and removal operations and their respective 
algorithms. 

Since a group of objects is established when several conditions hold true among the objects in the 
group, it must be ensured that when an object is either added or removed from a group that the 
group's organization is modified accordingly such that the conditions still hold true for all 
objects in the group. For example, simply changing the parent field of an object to the parent of 
its new group is not enough to remove the object from its current group and add it to a new 
group-the directly preceding object in the current group (if one exists) would still believe that 
the object (it's directly proceeding object) is its sibling object and therefore that it is still 
among the linked objects of the current group, however it now refers to a different parent object 
from the rest of the objects so by condition 2, a group is no longer established among those 
objects. Thus, the add and removal operations are separate operations that each involve several 
steps to either add or remove an object to/from their respective group and then re-establish the 
organization among objects in the group. 

Removing an object from its group
---------------------------------

The removal algorithm is almost identical to the algorithm for removal of [object] nodes in a singly 
linked list [of sibling objects]: 

An object's directly proceeding/sibling object determines the organization for all proceeding/remaining
objects in its group. When an object is removed from its group, its directly preceding object must 
know that the object is no longer its sibling, so the directly preceding object must replace its 
sibling with the now removed object's directly proceeding object/sibling since that is an object 
that still belongs to the group, but more importantly because it determines the organization for all 
proceeding/remaining objects in the group, thus preserving the organization of the group. 

(fig xx before removal of object[3] from its group)

   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |.                   |.                    |.                 
   |i  |p                 |p                      |p                   |p                   |p                    |p                 
   |l  |a                 |a                      |a                   |a                   |a                    |a                 
   |d  |r                 |r                      |r                   |r                   |r                    |r                        
   |r  |e                 |e                      |e                   |e                   |e                    |e                 
   |e  |n                 |n                      |n                   |n                   |n                    |n                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                 
   V   |   .sibling       |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]


(fig xx at object[2].process.sibling = object[2].process.sibling->process.sibling i.e. object[2].process.sibling = object[3].process.sibling)



   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |.                   |.                    |.                 
   |i  |p                 |p                      |p                   |p                   |p                    |p                 
   |l  |a                 |a                      |a                   |a                   |a                    |a                 
   |d  |r                 |r                      |r                   |r                   |r                    |r                        
   |r  |e                 |e                      |e                   |e                   |e                    |e                 
   |e  |n                 |n                      |n                   |n                   |n                    |n                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                 
   V   |   .sibling       |       .sibling        |                    |       .sibling     |        .sibling     |
object[0] ----------> object[1] ------------> object[2] -XXXXXXXX> object[3] ----------> object[4] ----------> object[5]
                                                  |                                         |^
                                                  -------------------------------------------
                                                                    .sibling

(fig xx after removal of object[3] from its group)
                                                                       .
                                                                       .
                                                                       |
                                                                       |
                                                                    object[3] --... 
                                                                       ^
                                                                       |
                                                                       |
   groupX <---------------\-----------------------\-----------------------------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |                    |.                    |.                 
   |i  |p                 |p                      |p                   |                    |p                    |p                 
   |l  |a                 |a                      |a                   |                    |a                    |a                 
   |d  |r                 |r                      |r                   |                    |r                    |r                        
   |r  |e                 |e                      |e                   |                    |e                    |e                 
   |e  |n                 |n                      |n                   |                    |n                    |n                   
   |n  |t                 |t                      |t                   |                    |t                    |t                 
   V   |   .sibling       |       .sibling        |                    |                    |        .sibling    
object[0] ----------> object[1] ------------> object[2]                                  object[4] ----------> object[5]
                                                  |                                         |^
                                                  -------------------------------------------
                                                                    .sibling


                                                                    If the last/rightmost object in a group is removed and it is not the only object in the group [i.e. 
it has a directly preceding object] its directly preceding object will become the last/rightmost 
object in the group: because the last object in a group lacks proceeding objects (and therefore has 
no organization of proceeding objects to preserve), after removal its directly preceding object then 
shall also have no proceeding objects and therefore no sibling object. Thus its sibling field must 
be changed to a null pointer-a characteristic of only the last object in a group: 

(fig xx before removal of object[5] from its group)

   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |.                   |.                    |.                 
   |i  |p                 |p                      |p                   |p                   |p                    |p                 
   |l  |a                 |a                      |a                   |a                   |a                    |a                 
   |d  |r                 |r                      |r                   |r                   |r                    |r                        
   |r  |e                 |e                      |e                   |e                   |e                    |e                 
   |e  |n                 |n                      |n                   |n                   |n                    |n                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                 
   V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

(fig xx at object[4].process.sibling = 0)
                                                                     
   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |.                   |.                    |.                 
   |i  |p                 |p                      |p                   |p                   |p                    |p                 
   |l  |a                 |a                      |a                   |a                   |a                    |a                 
   |d  |r                 |r                      |r                   |r                   |r                    |r                        
   |r  |e                 |e                      |e                   |e                   |e                    |e                 
   |e  |n                 |n                      |n                   |n                   |n                    |n                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                 
   V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |                     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] -XXXXXXXXX> object[5]


(fig xx after removal of object[5] from its group)
                                                                                                                
                                                                                                                  
   groupX <---------------\-----------------------\--------------------\--------------------\
   |.  ^                  |                       |                    |                    |                     
   |c  |                  |                       |                    |                    |                                      
   |h  |.                 |.                      |.                   |.                   |.                                     
   |i  |p                 |p                      |p                   |p                   |p                                     
   |l  |a                 |a                      |a                   |a                   |a                                     
   |d  |r                 |r                      |r                   |r                   |r                    .                        
   |r  |e                 |e                      |e                   |e                   |e                    .                 
   |e  |n                 |n                      |n                   |n                   |n                    .                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                                                                                                                     |
   V   |   .sibling       |      .sibling         |      .sibling      |       .sibling     |                     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4]           object[5]


Recall the 3rd condition that holds true for any group of objects: the parent object of the group 
points to first object in the group thru its 'children' field. If the first object in a group is 
removed then it will clearly no longer be the first object in that group, as it will no longer 
belong to the group. Thus the object's sibling, once the second object in the group, will then 
become the first object in the group-so the children field of the group's parent object must be 
changed to point to the new first object: 

(fig xx before removal of object[0] from its group)

   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |.                   |.                    |.                 
   |i  |p                 |p                      |p                   |p                   |p                    |p                 
   |l  |a                 |a                      |a                   |a                   |a                    |a                 
   |d  |r                 |r                      |r                   |r                   |r                    |r                        
   |r  |e                 |e                      |e                   |e                   |e                    |e                 
   |e  |n                 |n                      |n                   |n                   |n                    |n                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                 
   V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

(fig xx at object[0].process.parent->children = object[0].sibling)

   groupX <--------------\-----------------------\--------------------\--------------------\---------------------\
    |  ^                 |                       |                    |                    |                     |
    | |                  |                       |                    |                    |                     |                  
     \|.                 |.                      |.                   |.                   |.                    |.                 
      \p                 |p                      |p                   |p                   |p                    |p                 
      |\                 |a                      |a                   |a                   |a                    |a                 
      |r\  .children     |r                      |r                   |r                   |r                    |r                        
      |e \-----------\   |e                      |e                   |e                   |e                    |e                 
      |n              \  |n                      |n                   |n                   |n                    |n                   
      |t               | |t                      |t                   |t                   |t                    |t                 
      |    .sibling    V |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

(fig xx after removal of object[0] from its group)


                       groupX <-------------------\--------------------\--------------------\--------------------\
                       |. ^                       |                    |                    |                     |
                       |c |                       |                    |                    |                     |                  
                       |h |.                      |.                   |.                   |.                    |.                 
                       |i |p                      |p                   |p                   |p                    |p                 
                       |l |a                      |a                   |a                   |a                    |a                 
       .               |d |r                      |r                   |r                   |r                    |r                        
       .               |r |e                      |e                   |e                   |e                    |e                 
       .               |e |n                      |n                   |n                   |n                    |n                   
       |t              |n |t                      |t                   |t                   |t                    |t                 
       |               V  |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[0] --...      object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]


The removal algorithm consists of the following steps:

1) Is the object the first object in it's group?
   - Check the object's parent object ('parent' field): is the object pointed to in its parent object's 
     'children' field? If yes then the object is the first object in its group:
     a) Remove the object from its group:
        i) Point 'children' field of the object's parent object to the object's sibling (new first 
           object); if the object is the first and only object in its group then it does not have 
           a sibling, thus its' sibling' field is 0, so the children field of the object's parent
           object will also be set to 0-indicating that there is no longer a first object in the
           object's group and that there exists no objects in the object's group-a now empty group.
        ii) Return
2) The object is not the first object in its group
     a) Determine the object's directly preceding object:
        i) Check the 'children' field of the object's parent for the first object in its group
        ii) Start with the first object in the group and continue following sibling links until
        the object that has as its sibling the object that will be removed is found; this is the 
        directly preceding object
        iii) Remember object for next few steps
     b) Remove the object from its group:
        i) Set the object's directly preceding object's sibling field to point to the object's sibling;
           if the object is the last object in the group, then the object's sibling is null, so the
           directly preceding object's sibling field also becomes null (i.e the directly preceding 
           object becomes the last object in the group)
        ii) Return

Adding an object to a new group
-------------------------------

The add algorithm turns out to be much simpler than the removal algorithm: when an object is added 
to a new group, it can and will only be inserted at the beginning of the new group [of children]. 

If an object is added at the beginning of a group, it becomes the first object in that group, so 
the group's parent object must change it's 'children' field to point to that object-however doing 
just this replaces what the parent defined as the original first object in the group which 
determined the organization for all proceeding/remaining objects in the group-so the organization of 
those objects in the group is lost and therefore those objects no longer belong to that group. 

Ideally, by adding a new object to the beginning of a group, the original first object should then 
become the second object, the second object the third, and so on thus preserving the objects' 
organization. Since the first object in a group always points to the second object in the group thru 
its sibling field and since the original first object in the group intends to become the second 
object in the group, then prior to replacing the 'children' field of the group's parent object, the 
pointer in that field (i.e. the original first object in the group) must be copied to [i.e. 
preserved in] the sibling field of the new first object in the group, thus redefining the original 
first object in the group as the second object in the group-which then also preserves the 
organization for all proceeding/remaining objects in the group (i.e. original second object becomes 
the third and so on): 

(fig xx before adding of object[6] to groupX)

       .
       .
       |
       |
    object[6]--..

   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |
   |c  |                  |                       |                    |                    |                     |                  
   |h  |.                 |.                      |.                   |.                   |.                    |.                 
   |i  |p                 |p                      |p                   |p                   |p                    |p                 
   |l  |a                 |a                      |a                   |a                   |a                    |a                 
   |d  |r                 |r                      |r                   |r                   |r                    |r                        
   |r  |e                 |e                      |e                   |e                   |e                    |e                 
   |e  |n                 |n                      |n                   |n                   |n                    |n                   
   |n  |t                 |t                      |t                   |t                   |t                    |t                 
   V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

(fig xx at object[6].sibling = groupX.children i.e. object[6].sibling = object[0])

                      groupX <---------------\-----------------------\--------------------\--------------------\---------------------\
                      |.  ^                  |                       |                    |                    |                     |
                      |c  |                  |                       |                    |                    |                     |                  
                      |h  |.                 |.                      |.                   |.                   |.                    |.                 
                      |i  |p                 |p                      |p                   |p                   |p                    |p                 
                      |l  |a                 |a                      |a                   |a                   |a                    |a                 
                      |d  |r                 |r                      |r                   |r                   |r                    |r                        
       .              |r  |e                 |e                      |e                   |e                   |e                    |e                 
       .              |e  |n                 |n                      |n                   |n                   |n                    |n                   
       |              |n  |t                 |t                      |t                   |t                   |t                    |t                 
       |  .sibling    V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |        .sibling     |
object[6]---------->object[0] ----------> object[1] ------------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

(fig xx at groupX.children = object[6])


   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\---------------------\
   |.                   X |                       |                    |                    |                     |                     |
   |c                   X |                       |                    |                    |                     |                     |
   |h                   X |.                      |.                   |.                   |.                    |.                    |.
   |i                   X |p                      |p                   |p                   |p                    |p                    |p
   |l                   X |a                      |a                   |a                   |a                    |a                    |a
   |d                   X |r                      |r                   |r                   |r                    |r                    |r  
   |r  .                X |e                      |e                   |e                   |e                    |e                    |e
   |e  .                X |n                      |n                   |n                   |n                    |n                    |n
   |n  |                X |t                      |t                   |t                   |t                    |t                    |t
   V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |        .sibling     |        .sibling     |
object[6] ----------> object[0] ------------> object[1] ----------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

(fig xx after adding of object[6] to groupX; objectX[6].parent = groupX)


   groupX <---------------\-----------------------\--------------------\--------------------\---------------------\---------------------\
   |.  ^                  |                       |                    |                    |                     |                     |
   |c  |                  |                       |                    |                    |                     |                     |
   |h  |.                 |.                      |.                   |.                   |.                    |.                    |.
   |i  |p                 |p                      |p                   |p                   |p                    |p                    |p
   |l  |a                 |a                      |a                   |a                   |a                    |a                    |a
   |d  |r                 |r                      |r                   |r                   |r                    |r                    |r  
   |r  |e                 |e                      |e                   |e                   |e                    |e                    |e
   |e  |n                 |n                      |n                   |n                   |n                    |n                    |n
   |n  |t                 |t                      |t                   |t                   |t                    |t                    |t
   V   |    .sibling      |       .sibling        |      .sibling      |       .sibling     |        .sibling     |        .sibling     |
object[6] ----------> object[0] ------------> object[1] ----------> object[2] ----------> object[3] ----------> object[4] ----------> object[5]

Notice that the added object's 'parent' field must also be changed to point to the parent of the 
group that it is added to. (Condition 2) 

The add algorithm consists of the following steps:

add(object *src, sobject dst):
1) Set the object's 'sibling' field to point to the object in the 'children' field of 
   the destination group's parent object. 
   -If the destination group's parent object does not have an object in its 'children' field
    (i.e. = 0) then the destination group is empty and the sibling field of the object being
    added will become 0; since the object is being added as the first object in the destination
    group, then without a sibling it will become the first and only object in the group-thus by
    adding a single object to an empty destination group, the destination group changes from
    an empty group to one that contains a single object.
2) Set the destination group's parent object's 'children' field to point to the object
3) Set the object's 'parent' field to point to the destination group's parent object

Combining the add/removal algorithms
------------------------------------

The process of removing an object from its current group and subsequently adding it to a new group 
is referred to as the process of 'adopting' that object to a new group. The code for object adoption 
[i.e. code for object removal followed by object add] is repeated several times throughout the 
binary, thus deeming it the compiled code of a potential inline function in the original source. 

 --------------------------------------------------
| Object/process creation-createObject(): 0x1C6C8 |
 --------------------------------------------------

createObject() is one of the routines that the game uses to create a game object. It is used when 
the game wishes to 'create' an object that is a 'non-spawning' object-that is, the object is 
necessarily created by the game when the current level is initialized and its lifetime spans from 
level initialization until either the player dies or a new level is entered. A spawning object, in 
contrast, is created when the player enters an area of level that contains it-the game uses the 
'spawnObject()' routine to accomplish this; later sections discuss this in further detail. 

As discussed previously, when an object/process is created/instantiated, a free object is first 
'removed' from the group or 'pool' of free objects and then 'added' to the group of children 
associated with a destination 'parent' object; thus the object that will be created is adopted from 
the group of free objects to its destination group, or more appropriately in parent terms it is 
adopted from the free object to the destination parent object [whose children compose the 
destination group]. Since the object is removed from the group of free objects and is no longer a 
free object, the object's type is changed to 'in use' to reflect that it is now an existing object 
and can then be instantiated. The object is then instantiated given the 'type' of object to create, 
'subtype' among objects of its type to create, and an optional number of arguments that the object 
will be passed to its 'initial routine'. 

In the event that there exists no free objects and therefore no free object that can be adopted to 
the destination group and instantiated as a new object, the routine will additionally attempt to 
'terminate' specific objects that belong to groups[3]-thus providing the game with additional free 
objects in expense for otherwise less important objects. The code that handles this is another 
section of repeated inline code used in the same manner for the 'spawnObject()' routine-the section 
on 'object termination' discusses its function in more detail. If still no free object could be 
provided, the routine returns error (0xFFFFFFEA). The routine also copies various color data from 
the 'current zone' (current section of level that the player lies in) to the object after it is 
instantiated; this is yet another section of repeated inline code and is discussed in much later 
sections. 

The main purpose of this routine is object instantiation: createObject() accepts 5 arguments, the 
first argument [a pointer to] the 'destination' parent object to which a new object will be adopted 
before instantiation, the second and third arguments the 'type' and 'subtype' respectively of GOOL 
executable which the new object will be instantiated as, the fourth argument an array of unsigned 
long arguments ('args') to pass [during instantiation] to the object's 'initial routine', and the 
fifth argument the 'count' of arguments in the 'args' array. Thus, object instantiation is a 
separate routine that accepts as arguments the object to instatiate (i.e. the new object that is 
adopted to the destination parent), the 'type' and 'subtype' of object to instantiate, and 'args' 
and 'count' describing the optional arguments to pass to the object's initial routine. The object 
instantiation process and routine is discussed in the next section. 


createObject(parent, type, subtype, args, count):

a) if 'type' is 0 and 'subtype' is 0 then the requested GOOL executable to instantiate with is the 
   Crash executable, thus the 'player' object should specifically be adopted to 'parent' (rather 
   than some free object)
  
   ELSE adopt an object from free object to 'parent'
   - if a free object does not exist to be adopted then attempt to terminate objects in groups[3] to
     generate more free objects; if no free objects could be generated then return error (0xFFFFFFEA)

b) set adopted object's 'subtype' field to 3 (?)
c) instantiate adopted object as object/GOOL executable of 'type'/'subtype' with arguments described 
   by 'args' and 'count'

d) copy current zone colors to object colors  

 ----------------------------------------------------
| Object/process instantiation-initObject(): 0x1CB80 |
 ----------------------------------------------------

The initObject() routine accepts 5 arguments: an 'object' to instatiate (i.e. a new object that has 
been adopted to some existing object), the 'type' or ID/index of a GOOL executable that will be used 
to instantiate the object, the 'subtype' or initial state of execution for the object, an array of 
unsigned long 'args' to pass to the object's initial routine, and the 'count' of arguments in the 
args array. 

Object/process instantiation essentially performs all steps necessary for an object to eventually, 
elsewhere among the code for the object engine, begin its 'execution' by the GOOL bytecode 
interpreter. The routine first initializes the object's fields with their default inital values 
(mostly 0) and then uses the 'type' argument to look up the corresponding GOOL executable before 
occupying the object accordingly with data from that exectuable-wherein a map of all possible 
'states' for the object exists from which the object's initial state (with index 'subtype') is 
determined. 

The first part of this section gives a brief description/explanation of the various object fields 
that are initialized by the routine, including their initial values. Several of the fields that are 
initialized pertain to object data/members of the object structure whose purpose is only fully 
understood after reading much later sections. Thus, only a brief overview of each initialized field 
and its purpose throughout the game is given. 

The second part of this section begins to explain the GOOL executable entry format and the specifics 
of how that data from a GOOL executable entry occupies its destination object/processes' fields; 
this includes detailed descriptions of those fields and their purposes [and equivalently the 
descriptions of their source data fields from the executable entry], relative to the interpretation/ 
execution of the destination object itself and in the context of the GOOL engine. 

Brief descriptions of various object fields and their initial/default values
----------------------------------------------------------------------------

typedef struct
{ 
  unsigned long type;    //0x0          x
  unsigned long subtype?; //0x4
  ...
  entry *zone;           //0x28         x
  unsigned long state;   //0x2C
  ...
  typedef struct
  {
    object *self;                        x
    object *parent;
    object *sibling;
    object *children;
    object *creator;                     x
    object *player;                      x
    object *collider;                    x
    object *invoker;                     x
  
    typedef struct
    {
      cvector trans;
      cangle  rot;                       x
      cvector scale;                     x
      cvector velocity;                  x
      cangle  approach;                  x
      cvector misc;                      x
    } vectors;
  
    unsigned long statusA;       //0xC8  x
    unsigned long statusB;       //0xCC  x
    unsigned long statusC;       //0xD0  x
    unsigned long subtype;       //0xD4  x
    unsigned long PIDflags;      //0xD8  x (PID in left 3 bytes, flags in right byte)
    ...
    unsigned long *headBlock;    //0xF0  x
    ...
    unsigned long F8;           x
    ...
    unsigned char *aniSeq;      x
    unsigned long aniFrame;     x
    unsigned char *entity;      x
    signed long pathProgress;   x
    unsigned long pathCountEtc; x//num of paths in left 3 bytes, right byte unknown
    ... 
    signed long speed;          x
    unsigned long displayMode;  x
    ...
    unsigned long hitGroundStamp; x
    ...
    unsigned long zIndex;       x   
    ...
    signed long camZoom;        x
    ...
    signed long hotspotClip;    x
    unsigned long _14C;         x
    ...
    unsigned long memory[0x41]; x

  } process;      //0x60
} object;  


1) Memory separator? 

Each object/process has at most 65 unsigned longs (65 longs x 4 bytes = 260 bytes) of its own local 
'object memory' to work with. Eventually, it will be seen that the GOOL bytecode interpreter uses 
the object's local memory to read source operands for and/or store the results of (push/pop) 
operations carried out as the result of interpreting GOOL instructions within the GOOL bytecode item 
data-located in the object's corresponding executable entry. 

The routine begins by setting the first long of the object's memory ('memory[0]') to 0xFFFF. (It is 
unknown whether the actual purpose is to act as an indicator for the beginning of object memory or 
im dumb and i forgot how this field is actually used lol) 

2) Object/process ID: PID ('PIDflags')

Each existing object/process has its own unique numerical identifier or 'PID'. An object's actual 
PID exists in the leftmost 3 bytes of its 'PIDflags' field, which has the following bitwise format: 

PPPPPPPP PPPPPPPP PPPPPPPP FFFFFFFF

P = PID
F = (misc flags?)

Thus: (PIDflags >> 8) = PID
The actual value for PIDflags is determined when the object is spawned.

initObject sets the initial value for the PIDflags field to 0. 

3) Object/process spawning entity ('entity')

As the player makes progress throughout the level, a majority of the game objects are spawned 
according to the 'entities' that the player encounters in the level; the level layout describes the 
entities in a level, which includes location, type, etc. When an object is spawned, a pointer to the 
entity that caused the object to spawn is saved in the object's 'entity' field. 

initObject sets the inital value for entity to 0.

4) Object/process path progress ('pathProgress')

Various spawnable game objects behave by moving along a fixed path defined in the data for the 
object's entity. An object's path is described in the object's entity by a series of connected 
points; an object's path progress value indicates how far the object is into its path and is used as 
the weight in a point-along-path interpolation to calculate the object's location relative to its 
starting location. 

initObject sets the initial value for pathProgress to 0.

5) Object/process path count ('pathCountEtc') (something else?)

This value determines the number of distinct points that define the object's path.

initObject sets the initial value for pathCountEtc to 0.

6) Object velocity vector, approach angle, and misc vector ('vectors.velocity', 'vectors.approach', 'vectors.misc')

Vectors are described in the object physics(?) section.

initObject sets the initial (X, Y, and Z) components for vectors.velocity, vectors.approach, and 
vectors.misc to 0. 

7) Object speed ('speed')

The object's speed determines the magnitude from which the object's velocity vector is calculated in 
the object physics routine. 

initObject sets the initial value for speed to 0.

8) Object animation frame ('aniFrame')

The object's animation frame determines the [index of the TGEO] model in the object's current 
animation sequence that is used to render the object. 

initObject sets the initial value for aniFrame to 0.

9) F8 = ? TODO

10) TYPO?

11) Object status flags ('statusA', 'statusB', 'statusC')

The object's status flags describe multiple aspects of the object's current behavior or status-this 
includes flags that indicate whether the object has just hit solid ground, is rotating clockwise or 
counter-clockwise, is affected by gravity, needs a bounding-box recalculation and etc. 

initObject sets the initial values for statusA, statusB, and statusC to 0.

12) Object display mode ('displayMode')

The object's display mode determines whether the object is rendered normally, as a flashing object, 
or as some other variation of its default appearance. 

initObject sets the initial value for displayMode to 0.

13) Object Z-index ('zIndex')

Although most objects in the game are rendered in an order determined by their projected Z-distances 
from the camera during the rendering stage, a few objects (i.e. HUD display, lives icon, etc.) must 
be rendered only after all other objects have been rendered-thus these objects will always appear 
-in front- of all other objects. This field determines the priority or ordering of the object during 
the rendering process. 

(TODO: or is this needed since certain, specifically 2-dimensional, objects cannot be calculated an 
appropriate projected Z-distance or is this equivalent to what has already been said) 

initObject sets the initial value for zIndex to 0.

14) Object timestamp for last instance of touching solid ground ('hitGroundStamp')

Whenever the object hits solid ground/floor (i.e. is stopped from falling due to colliding with 
solid ground), a timestamp is recorded in this field. When the object is air-bound it can then 
calculate how long it has been off of the ground by subtracting this field's value from the current 
time if necessary. 

initObject sets the initial value for hitGroundStamp to 0.

15) Object hotspot/collision space clip ('hotspotClip')

When a pair of objects are tested for collision, the calculated cubic region of 3-dimensional space 
occupied by one of the objects is clipped of/subtracted by an equal number of units in width, 
height, and depth before performing the necessary comparisons with the calculated cubic region of 3d 
space occupied by the other object- these comparisons are also done starting with the other object. 
This field determines the number of units to clip from the object's 3d space during a collision 
test, as described above. 

initObject sets the initial value for hotspotClip to 0.

16) FIELD 0X14C???? ('_14C')

The purpose of field 0x14C is currently unknown.

initObject sets the initial value for _14C to -2.

17) Object current zone, rotation, and scale vectors ('zone', 'vectors.rot', 'vectors.scale')

The object's current zone refers to item data that describes the current portion of the level where 
the object lies. Zones and vectors (including rotation and scale vectors) are discussed in more 
detail in later sections. 

Earlier in the creation process, if the object had been adopted to a parent that is an existing 
object (i.e. a non-head and non-free object = type 1) it is necessary that the object inherits some 
of its parent's attributes. 

If the object's parent is an existing object (type 1):

-initObject sets the initial value for 'zone' to that of its parent object 
 (thus the object exists in the same zone as its parent)
-initObject sets the initial (X, Y, Z) components for both [its rot and scale vectors=] vectors.rot and 
 vectors.scale to the same (X, Y, Z) components of its parent's [rot and scale vectors=] vectors.rot and 
 vectors.scale

If the object's parent is NOT an existing object, i.e. a head object (type 2):

-initObject sets the initial value for zone to 0.
-initObject sets the initial (X, Y, Z) components for vectors.rot to 0.
-initObject sets the initial (X, Y, Z) components for vectors.scale to 0x1000.
 
Additionally, certain types of GOOL executable would instantiate an object that could not exist in 
any portion or 'zone' of the level and would therefore exist separately from the level. (ex. HUD 
display executable) (EDIT: contradiction, 5 = akuaku, 29 = shadow) 

-if 'type' is 4, 5, or 29:
 initObject always sets the initial value for zone to 0

18) Object camera zoom ('camZoom')

In levels, the camera behaves by following the player object... etc (TODO)

-if 'type' is 0 (crash executable)
 initObject sets the initial value for camZoom to 0

GOOL Executable entries & GOOL Process basics
---------------------------------------------

A GOOL executable entry includes all the necessary data to describe the functionality or application 
of a particular type of game object. 

The 'execEIDMap' array from the NSD structure (at ... in the NSD file) is a list of up to 64 EIDs 
for all possible GOOL executable entries that exist in the NSF file, indexed by GOOL executable 
'type' [ID/index]. Thus, the array maps GOOL executable types to their corresponding executable 
entries. 

For the majority of game modes/levels, a copy of the same GOOL executable can exist in each of the 
corresponding NSF files; for example, a copy of the same Crash executable entry exists in the NSF 
files for each of the following levels: N. Sanity Beach, Rolling Stones, The Great Gate, Boulders, 
...etc-essentially all levels that involve the Crash object. The same goes for box/crate 
executables, fruit executables, the HUD/display executable, and generally all executable [types] 
that are 'universal' to the game. In most of the NSD files, the execEIDMap array lists the EIDs for 
these universal executables at the same indexes; thus, if an EID exists that is not at one of the 
'universal indexes' in the execEIDMap array of some NSD file then its corresponding executable is 
either local to only the corresponding NSF file or may exist as a copy in few other NSF files-other 
NSD files will likely refer to a different EID [or none at all] at that index. 

The following table lists all universal GOOL executables in the game by type (index of their EID in 
the execEIDMap arrays of most NSD files), EID (represented as a 5 character string), and 
purpose/description: 

------------------------------------------------------------------------------
| Type |   EID   |                       Description                         |
------------------------------------------------------------------------------
|   0  |  WillC  | 'Willy Wombat' (Crash Bandicoot) [executable] object code |
|   3  |  FruiC  |                      Wumpa Fruit [executable] object code |
|   4  |  DispC  |                      HUD Display [executable] object code |
|   5  |  DoctC  |                 'Doctor' Aku Aku [executable] object code |
|  29  |  ShadC  |                    Shadow Object [executable] object code |
|  32  |  WarpC  |                 Warping Sequence [executable] object code |
|  34  |  BoxsC  |                        Box/Crate [executable] object code |
------------------------------------------------------------------------------

The initObject routine first uses the 'type' argument as an index into the execEIDMap array of the 
NSD structure to locate the EID of the executable entry of that type and then calls the pageEntry 
routine with the EID as an argument to page the corresponding entry from the NSF file and resolve a 
pointer to the paged entry [data]. A pointer to this entry is then saved in the object's 'global' 
field; the pointer in this field is then said to refer to the object's instantiating GOOL executable 
entry. If the entry fails to page, the routine will return error (0xFFFFFFF2). 

A GOOL executable entry includes at most 6 items:

--------------------------------------
| Index | Description of Item's Data |
--------------------------------------
|   1   |     header/metadata        | 
|   2   |      GOOL bytecode         |
|   3   |    static variable data    |
|   4   |     event/subtype map      |
|   5   |      state definitions     |
|   6   |   animation descriptors    |
-------------------------------------

These items have the following structure:

typedef struct
{ 
  unsigned long type;
  unsigned long class;
  unsigned long nonlinked;
  unsigned long initSP;
  unsigned long subtypeMapOffset;
  unsigned long ?;
} GOOL_header;

typedef struct
{
  unsigned long code[n];
} GOOL_code;

typedef struct
{
  unsigned long data[n];
} GOOL_data;

typedef struct
{
  unsigned short eventMap[subtypeMapOffset];
  unsigned short subtypeMap[n];
} GOOL_map;

typedef struct
{
  typedef struct GOOL_state
  {
    unsigned long type;
    unsigned long flags;
    unsigned short indexExecEID;
    unsigned short eventBlocksOffset;
    unsigned short transBlocksOffset;
    unsigned short codeBlocksOffset;
  } states[n];
} GOOL_states;

The structure of the 6th item is irrelevant at this point.

At this point it is also considered necessary that the "Intro to Game Engines with Interpreted AI" 
guide be read to fully understand the concepts that will be introduced. 

As discussed previously, the main purpose of instantiation for the object is so that, elsewhere 
among the code for the object engine, the object can begin its 'execution' by the GOOL bytecode 
interpreter. The GOOL bytecode interpreter executes an object by sequentially fetching/interpreting 
instructions (i.e. unsigned longs) located in the GOOL_code [item] of the executable entry that 
instantiated the object, and performing their corresponding operations. Additionally, for the GOOL 
bytecode interpreter to perform those operations, the object needs a certain amount of its own stack 
memory to store the results of those operations and/or to read and use as the operands for 
subsequent operations. 

Thus, the GOOL bytecode interpreter routine expects an object that knows the following:

- Where to take instruction 
  = object's program counter - the location in the object's byte code from which the interpreter shall 
    begin interpretation or its process of sequentially fetching instructions and performing their 
    corresponding operations 
- Where to commit to/read from memory
  = object's stack pointer - wherein the object's memory the interpreter shall begin pushing the results 
    of/popping the operands for the operations of interpreted instructions 
- How to take instruction
  = interpreter status flags - how the flow of interpretation might be affected by the operations of 
    various instructions 

An object determines -where- it should begin taking instruction based on the -kind- of 
interpretation that shall be performed. Up to 5 distinct interpretations of an object's code can 
occur in a single iteration of the main game loop; equivalently, the GOOL bytecode interpreter 
routine ('interpret()') can be called on the same object from up to 5 distinct locations in a single 
iteration of the main game loop: 

  MAIN LOOP:
  {
     ...
   2) or 5)
     ...
       initObject(object, ...)
         changeState(object, ...)
           ...
           newFrame(object)
           object->process.pc = object->process.headBlock;
           interpret(object, 3, &ret) // # 1
           ...
          ...

        issueEvent(sender, object, ...)
          -if there is an event service routine for the object (in its current state)
            ...
            newFrame(object);
            object->process.pc = object->process.eventBlock;
            interpret(object, 8, &event); // # 2

          -if event is non-state changing event
            ...
            newFrame(object);
            object->process.pc = gool_CODE(object, event);
            interpret(object, 3, &ret);  // # 3

          -else
            changeState(object, ...);
           
   9) Execute, animate, and render primitives for all objects (includes physics and collision engine)
        sub_8001D5EC - handleObjects()
          for each existing object do:
            ...
            -if at least one object frame worth of time for this object has elapsed since the following
            has been performed (i.e. since the object has last executed its trans block):

              newFrame(object);
              object->process.pc = object->process.transBlock;
              interpret(object, 3, &ret)  // # 4

              -if at least n ticks have elapsed, where n is given by the 'wait' operand of the most recently 
               suspending animation type instruction of the object's code block: 

               interpret(object, 4, &ret);  // # 5
              ...
  }

Thus, a potential sequence of instruction reads as a result of multiple calls to the interpret 
routine for the same object in one iteration of the main game loop could be: 

Offset/address | Instruction
---------------|-------------
headBlock: 0x0 |      N
           0x4 |      N
           0x8 |      N
           0xC |      S
.....          |     
eventBlock:0x34|      N
           0x38|      N
           0x3C|      S
.....          |
transBlock:0x50|      N
           0x54|      N
           0x58|      N
           0x5C|      N
           0x60|      N
           0x64|      N
           0x68|      S
.....          |
codeBlock: 0x70|      N
           0x74|      N
           0x78|      N
           0x7C|      N
           0x80|      S

Where the offsets/addresses of the interpreted instructions from the object's instantiating 
executable entries' bytecode item are indicated in the left column along with labels at the offsets 
that are pointed to in their respective object fields of the same name, and whether the instructions 
either did not suspend execution-causing the next instruction in sequence to be read/interpreted 
(indicated by an N)-or did suspend execution-causing the interpreter routine to return to the callee 
(indicated by an S). 

These object fields/pointers (headBlock, eventBlock, transBlock, codeBlock) define, for some object, 
the absolute locations of 'blocks' in the object's code that the object's program counter will be 
changed to point at, prior to each respective type of interpretation [during the iteration of the 
game loop in which the object is created]. Equivalently, they define the respective entry points for 
4 separate -threads- of execution for an object-a head thread, an event thread, a trans thread, and 
a code thread. 3 of these object fields/pointers change whenever the object 'changes state', which 
is accomplished with the 'changeState()' routine. 

After the initObject() routine pages and resolves a pointer to the object's instantiating entry and 
saves this pointer in the object's 'global' field, a few of the object's other fields are 
additionally initialized with their initial values; these initializations are discussed further 
below. The routine then determines, from the given, desired 'subtype' for the object in the routine 
arguments, the appropriate object 'state' corresponding to that subtype by resolving its numerical 
value from the data at that index in the 'subtypeMap' array of the 'GOOL_map' item [i.e. item 4] in 
the object's instantiating entry; this particular state is referred to as the object's 'initial 
state'. If this initial state is not a 'null state' (has the value 0xFF), then it is used as an 
argument in a call to the 'changeState()' routine, which effectively performs all the necessary 
operations for changing the object's state to -that- state; if the initial state is, however a 'null 
state' the routine returns error (0xFFFFFFE5). The initObject() routine then returns either 
0xFFFFFF01 if the change in state was successful (i.e. value returned by changeState() is not in the 
range 0xFFFFFFEE-0xFFFFFFFF of 'GOOL error codes') or 0xFFFFFFF2 if it was not. 

In part of its operation, the changeState() routine uses the state that it is passed as an index 
into the object's state definitions, or 'states' array of the 'GOOL_states' item [i.e. item 5] in 
the object's instantiating entry. Relative offsets from the 'eventBlocksOffset', 
'transBlocksOffset', and 'codeBlocksOffset' fields of the state definition structure at that index 
are then used to calculate the corresponding absolute offsets into the object's GOOL byte code 
[GOOL_code item of its instantiating entry]. These offsets then replace the previous offsets in the 
object's respective 'eventBlock', 'transBlock', and 'codeBlock' fields. With these fields set, the 
GOOL bytecode interpreter can then determine where it should start fetching instructions-and 
equivalently, the object knows where it should begin taking instruction-in any interpretation/call 
to interpret() during some iteration of the main game loop. 

Several additional initializations of data in the object's fields are performed between paging the 
object's instantiating entry and changing the object's[/setting the object's initial] state. These 
are as follows: 

1) Object links ('self', 'creator', 'player', 'collider', 'invoker')

The object's links are pointers to various other object's associated with the object.

self     - This field always points to the object itself.
creator  - This field is used to point to an alternative type of 'parent' object that created the object
           as one of its 'nested' objects by the operation of some specific gool instruction. 
player   - This field always points to the 'player' object (i.e. crash object).
collider - This field is used to point to another object that collides with the object when detected 
           [Collision detection done by the collision portion of the physics engine.]           
invoker  - This field is used to point to another object that -issued- a GOOL event to the object.

- initObject sets the initial value for 'self' to point at the location of the beginning of the object's structure
- initObject sets the initial value for 'creator'  to 0
- initObject sets the initial value for 'collider' to 0
- initObject sets the initial value for 'invoker'  to 0
- initObject sets the initial value for 'player' to that of 'player'(?) from the GOOL structure

2) Object subtype ('subtype')

The object's subtype specifically determines its initial state of operation, where objects of 
different subtypes operate (appear/behave) differently. 

- initObject sets the initial value for 'subtype' to that of the routine's argument with the same name

3) Object animation sequence ('aniSeq')

The object's animation sequence at any instant can be a pointer to one of the 'animation 
descriptors' in the GOOL_anim item of the object's instantiating executable entry; most of these 
animation descriptors describe a sequence of TGEO models that the object can choose among to 
determine which will render the object during the rendering stage of the main game loop. 

- initObject sets the initial value for 'aniSeq' to 0

4) Object head block ('headBlock')

The object's head block is a [pointer to a] block in its GOOL code [GOOL_code item of its 
instantiating executable entry] that shall be interpreted only once, prior to/during each state 
change that is undergone. 

- initObject sets the initial value for 'headBlock' to 0

 ----------------------------------------------------
| Object/process state change-changeState(): 0x1D698 |
 ----------------------------------------------------

The changeState() routine accepts 4 arguments: an 'object' whose state shall be changed, a 'state' 
or integer that indicates the state that the object shall change to, a pointer to an array of 
unsigned long 'args' that shall be passed to the object's initial routine, and the 'count' of args 
in that array. 

The routine begins by checking if the 'state' passed as an argument is a 'null state'-indicated by 
the value 0xFF; if the state is a null state then the routine returns error (0xFFFFFF02). 
Additionally, the routine checks if bit 29 of the object's 'statusB' flags is set; if so, then the 
routine returns error (0xFFFFFF02). If both of these checks pass, then the routine continues by 
firstly setting the value of the object's 'state' field to the state passed in the routine 
arguments. 

The routine then uses the state that it is passed as an index into the object's state definitions-or 
'states' array of the 'GOOL_states' item [i.e. item 5] in the object's instantiating entry 
('global')-to resolve that state's corresponding state definition [structure]. The data fields in 
the state definition structure (GOOL_state) have the following purposes: 

'type'              - set of flags that indicate the type of state, ex. is a ground state, air state, solid state, terminable state
'flags'             - set of flags that specify a set of requirements for the object in this state to transition to another state
'indexExecEID'      - index of the unsigned long in the GOOL_data item of the containing entry that is the EID of the actual 
                      *specified executable entry whose GOOL_code item the following block offsets are given relative to
'eventBlocksOffset' - relative offset in instructions [i.e. unsigned longs = *4 bytes] of the event block in the *specified entry's 
                      GOOL_code item that shall be interpreted in this state
'transBlocksOffset' - relative offset in instructions [i.e. unsigned longs = *4 bytes] of the trans block in the *specified entry's 
                      GOOL_code item that shall be interpreted in this state
'codeBlocksOffset'  - relative offset in instructions [i.e. unsigned longs = *4 bytes] of the  code block in the *specified entry's 
                      GOOL_code item that shall be interpreted in this state

At this point, as discussed previously, the routine determines -where- the object should begin 
taking instruction for the eventual respective interpretations of its code: 

The routine uses the value of the 'indexExecEID' field in the structure as an index into the 
object's instantiating executable entry's GOOL_data item to determine the EID of the executable 
entry whose GOOL_code item the state definition structure's 3 block offsets are given relative to. 
The routine then calls the pageEntry routine with that EID as an argument to potentially page the 
corresponding entry from the NSF file and resolve a pointer to the [possibly already] paged entry 
[data]. A pointer to that entry is then saved in the object's 'external' (TODO: rename 
appropriately) field. 

Then the routine uses the 'codeBlocksOffset' relative offset in the state definition to calculate 
the absolute location of/pointer to the instruction that begins the corresponding code block within 
the object's 'external' entry's GOOL_code item. This calculated location is then stored in the 
object's 'pc' field, or equivalently, as the object's new program counter location. (i.e. 
object.process.pc = &object.external.GOOL_code[codeBlocksOffset * 4]). If the 'codeBlocksOffset' 
offset specified in the state definition has the value '0x3FFF', or equivalently, is a NULL 
code/block offset/location, then the object's 'pc' field is instead set to 0. 

Then the routine uses the 'eventBlocksOffset' relative offset in the state definition to calculate 
the absolute location of/pointer to the instruction that begins the corresponding event block within 
the object's 'external' entry's GOOL_code item. This calculated location is then stored in the 
object's 'eventBlock' field, or equivalently, as the object's new event block location. (i.e. 
object.process.eventBlock = &object.external.GOOL_code[eventBlocksOffset * 4]). If the 
'eventBlocksOffset' offset specified in the state definition has the value '0x3FFF', or 
equivalently, is a NULL code/block offset/location, then the object's 'eventBlock' field is instead 
set to 0. 

The routine then repeats the above process with the 'transBlocksOffset' relative offset in the state 
definition, but instead setting the object's 'transBlock' field accordingly; this determines the 
object's new trans block location. 

Then, at this point, as discussed previously, the routine determines -where- the GOOL byte code 
interpreter shall commit to/read from the object's memory: 

The routine uses the 'initSP' relative offset from the object's instantiating GOOL executable 
entry's GOOL_header item to calculate an absolute pointer to the location that is initSP -unsigned 
longs- relative to the object's 'process' structure (which is located at 0x60 bytes into the 
object's structure)-this determines the new initial location of the object's 'stack' (which 
-should-, where initSP has been precomputed such that it shall, lie within the object's array of 
'memory'). The routine then stores this pointer in the object's 'sp' field, or equivalently, as the 
object's stack pointer. The object's stack pointer will then eventually be used to push data to or 
pop data from the top of the object's stack by dereferencing it to either store data at or read data 
from its current location and then incrementing or decrementing its location accordingly.  

Then the routine sets the object's 'fp' field, or equivalently, the object's 'frame pointer' to 0. 
This field is used to point to the beginning of the object's current 'stack frame' [which is a 
location on the object's stack/in the object's memory.] A new stack frame is created for the object 
at some instant by pushing this predefined sequence of object fields (and a local variable used by 
the GOOL byte code interpreter) to preserve their values: GOOL interpreter status flags, the 
object's program counter location ('pc'), and an unsigned long that is divided into a pair of 
unsigned shorts which indicate the respective relative offsets of the object's frame pointer ('fp') 
and stack pointer ('sp'). An object's frame pointer and stack pointer define the 'range' of its 
current stack frame. Prior to an interpretation, it is necessary that a new stack frame is created 
if one does not already exist for that interpretation; when the interpretation performs the 
operation for an instruction in an object's GOOL byte code, it may pop the operands off and/or push 
the results of the operation to the object's stack, thereby shortening or adding additional content 
to that stack frame. When the interpretation reaches a return instruction, it can peek the preserved 
values at the beginning of that frame to restore the original data in the object's fields. [If 
unfamiliar, these concepts are explained in greater detail in the "Intro to Game Engines with 
Interpreted AI" guide.] 

The routine then pushes the 'count' arguments from the array of 'args' to the object's stack (prior 
to creating the object's initial stack frame); these arguments can then be peeked at by the 
operations of instructions in the interpretation corresponding to the following stack frame that 
will be created. [Of course, since these arguments shall then precede the beginning of that stack 
frame, to peek any of their values in an interpretation would require that a -negative- relative 
offset with respect to the object's frame pointer be specified as an operand in some interpreted 
GOOL instruction whose operation would dereference the value at that location.] 

The routine then creates the object's initial stack frame with a call to the 'newFrame()' routine; 
this frame is used specifically by the object's code block interpretation. The argument 'count' 
adjustment factor passed to newFrame() is the 'count' of arguments passed as the 'count' argument to 
the current routine; the interpreter 'status' flags passed to the routine are the value 0x0000FFFF. 
The purposes of these arguments are explained with greater detail in the section for the 
'newFrame()' routine; the 0x0000FFFF interpreter status flags passed indicate that the interpreter 
does not yet have any status flags to preserve, for an interpretation of the object's code block has 
not yet occurred. 

Then at this point, the routine sets some additional fields in the object for the eventual 
interpretation of its code to behave appropriately: 

The routine then sets bit 18 and bit 6 in the object's 'statusA' flags. When bit 18 of the 'statusA' 
flags is set, it indicates that the object will have undergone a state transition by this routine's 
completion. For one type of interpretation, i.e. one that can potentially be performed on top of 
some other interpretation via the operation of a specific kind of GOOL instruction reached-referred 
to as instruction 'A' for this description-a number of arguments are pushed to the object's stack 
and a new stack frame is naturally created prior to its performance. Such an interpretation may 
reach an instruction-referred to as instruction 'B' for this description-whose operation would cause 
a state transition/call to this routine, changeState(); since this routine already causes the 
object's stack pointer and frame pointer to be reset to their initial locations and consequently the 
object's stack to be 'cleared', then when the interpretation is completed/returns, it is not 
necessary that the continued operation of instruction 'A' performs its default task of then popping 
the [now non-existent] arguments pushed. Then, when bit 18 of the object's 'statusA' flags is set, 
instruction A's operation will not pop those arguments; this bit is then cleared along with a number 
of other similarly handled statusA flags towards the end of the object handling routine, occurring 
after both the object's trans block and code block interpretations-such that all potential nested 
interpretations [that may have caused a state transition] will have completed. Bit 6 is discussed in 
later sections. 

Then the routine sets the value of the object's 'stateFlags' field to that of the 'type' field from 
the state definition [structure]. Flags in this field indicate the presence/lack of some specific, 
predefined behaviors for the object [in its state] that are hard-coded into the object/physics 
engines (performed in addition to their usual interpretations). Equivalently, they define the 
compound type of state for that object; for example, a 'solid and air' type state would cause the 
collision engine to consider that object a solid, collidable object, and the physics engine to cause 
the object to fall and accelerate towards the ground. 

The routine also sets the value of the object's 'statusC' field to that of the 'flags' field from 
the state definition [structure]. Flags in this field may be modified by various parts of the game 
engine; when the object attempts a state change by the interpretation of a state changing 
instruction in its code, if any of these flags have been modified to yield a different value from 
the original 'flags' in the state definition, the state change will not occur. Currently, not much 
else is known about this field. 

Next, the routine attempts to perform the object's 'head block' interpretation:

By the previous operation of some interpreted instruction in the object's code, a pointer to the 
absolute location of some block of its code may have been specified as an operand for its ultimate 
storage in the object's 'headBlock' field. At any instant, if such a pointer existed for the object 
(i.e. its 'headBlock' field were not zero), then the block that it pointed to should be interpreted 
in a single, one-shot interpretation that would occur at this point: the point of the object's next 
state change-or more specifically, following the creation of the object's initial stack frame in its 
next state change. 

If the object's 'headBlock' field/pointer is not null, then the following steps are carried out in 
performing the interpretation for the object's [existing] head block [referred to by its 'headBlock' 
pointer]: 

  - create a new stack frame for the object (with args: count = 0 and status = 0xFFFF) 
  - set object's program counter to the [pointed] location of/[in] its 'headBlock' [field]
  - *set the object's 'headBlock' field to 0
  - do interpretation:
    - call interpret() with args: object = object, (binary) status = 00000011, ret = some new static variable
    - if interpret() returns a GOOL code in the range of GOOL error codes:
       - return [from changeState()] with that code
  
If the object's 'headBlock' field/pointer IS null, then the routine pushes a 0 to the top of the 
object's stack [at that point, adding to the object's initial stack frame] as the value for 'wait': 
it will eventually be seen that the value of 'wait' is peeked from the object's stack prior to the 
potential interpretation of its code block (occurring in a single iteration of the main game loop, 
during the execution of the object engine/handleObject() routine)- if this value refers to a number 
of time units that is greater than the number of time units that have elapsed since the previous 
interpretation of the object's code block, then the interpretation of its code block will not occur 
in the respective iteration; conversely if it refers to a number of time units that is less than or 
equal to the number of time units that have elapsed since the previous interpretation, then 'wait' 
will be popped off of the object's stack, and the interpretation of its code block will then be 
performed. The operation of some GOOL 'ANIF' (and 'ANIS'?) instruction that exists in the object's 
code block during its interpretation will then push back a new value for 'wait' and cause the 
interpreter to return from/suspend that interpretation, repeating this process for subsequent 
iterations of the game loop. 

When an object's head block interpretation does occur, its ultimate operation should determine and 
push the 'initial' value for 'wait' to the object's stack; conversely, if that interpretation is not 
performed, then the value for 'wait' is -always- pushed as a 0. 

*If the object's head block interpretation does occur, when setting the object's 'headBlock' field 
to 0, this strictly specifies that the interpretation of that block or any other head block should 
not occur in subsequent state changes UNLESS if, in following interpretations, a GOOL instruction is 
interpreted [prior to any subsequent state changes] whose operation resets the headBlock field to 
point to a new head block. 

Next the routine... TODO: explain this interpretation

 ----------------------------------------------------
|  GOOL byte code interpreter-interpret(): 0x201DC  |
 ----------------------------------------------------

 
 ....
 
 GOOL instruction table
 ----------------------
 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------
 |          |      |                                     |explicit|*explicit|implicit |                          |implcit|explicit|
 |  Opcode  | Name |           Encoding/Format           |GOOL ops|CONST ops|STACK ops|         Operation        | STACK |GOOL ops|  Description
 |          |      |                                     |   in   |   in    |   in    |                          |  out  |  out   |
 -----------------------------------------------------------------------------------------------------------------------------------------------------------
 | 0 / 0x00 | ADD  | 00000000 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L + R        |   O   |        |  add 
 | 1 / 0x01 | SUB  | 00000001 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L - R        |   O   |        |  subtract
 | 2 / 0x02 | MUL  | 00000010 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L * R        |   O   |        |  multiply
 | 3 / 0x03 | DIV  | 00000011 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L / R        |   O   |        |  divide
 | 4 / 0X04 | CEQ  | 00000100 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |        O = (L == R),     |   O   |        |  check if equal
 |          |      |                                     |        |         |         |      O = ((L ^ R) == 0)  |       |        |          
 | 5 / 0x05 | ANDL | 00000101 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |        O = (L && R),     |   O   |        |  logical and
 |          |      |                                     |        |         |         |    O = (L ? (R > 0) : 0) |       |        |
 | 6 / 0x06 | ORL  | 00000110 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |        O = (L || R)      |   O   |        |  logical or
 | 7 / 0x07 | ANDB | 00000111 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L & R        |   O   |        |  bitwise and
 | 8 / 0x08 | ORB  | 00001000 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L | R        |   O   |        |  bitwise or
 | 9 / 0x09 | SLT  | 00001001 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L < R        |   O   |        |  set less than
 |10 / 0x0A | SLE  | 00001010 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |        O = (L <= R)      |   O   |        |  set less than or equal
 |11 / 0x0B | SGT  | 00001011 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L > R        |   O   |        |  set greater than
 |12 / 0x0C | SGE  | 00001100 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |        O = (L >= R)      |   O   |        |  set greater than or equal
 |13 / 0x0D | MOD  | 00001101 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L % R        |   O   |        |  modulus
 |14 / 0x0E | XOR  | 00001110 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         |         O = L ^ R        |   O   |        |  exclusive or
 |15 / 0x0F | TST  | 00001111 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         | O = (((L & R) ^ R) == 0) |   O   |        |  test bit
 |16 / 0x10 | RND  | 00010000 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         | O = L +(rand() % (R - L))|   O   |        |  random
 |17 / 0x11 | MOVE | 00010001 SSSSSSSS SSSSDDDD DDDDDDDD |   S    |         |         |           D = S          |       |  [D]   |  move data
 |18 / 0x12 | NOTL | 00010010 SSSSSSSS SSSSDDDD DDDDDDDD |   S    |         |         |        D = (S == 0)      |       |   D    |  logical not
 |19 / 0x13 | PRW  | 00010011 JJJJJJJJ JJJJXXXX XXXXXXXX |  X,[J] |I = 0x100|  [I,J]  |           varies         |   P   |   X    |  path progress rewind
 |20 / 0x14 | LEA  | 00010100 SSSSSSSS SSSSDDDD DDDDDDDD |   S    |         |         |           D = &S         |       |   D    |  load effective address
 |21 / 0x15 | SHA  | 00010101 RRRRRRRR RRRRLLLL LLLLLLLL |  L,R   |         |         | O = ((R < 0) ? (L >> -R) |   O   |        |  arithmetic shift
 |          |      |                                     |        |         |         |              : (L <<  R))|       |        |             
 |22 / 0x16 | PSH  | 00010110 AAAAAAAA AAAABBBB BBBBBBBB |  A,B   |         |         |       [arg_buf = A]      |[A,[B]]|        |  push to stack   
 |23 / 0x17 | NOTB | 00010111 ...                        |        |         |         |                          |       |        |  bitwise not
 |24 / 0x18 | MOVC | 00011000 0000MMMM MMCCCCCC CCCCCCCC |        |   M,C   |         |         see docs         |   O   |        |  move code pointer
 |25 / 0x19 | ABS  | 00011001 SSSSSSSS SSSSDDDD DDDDDDDD |   S    |         |         |   D = (S < 0) ? -S: S    |       |   D    |  absolute value
 |26 / 0x1A | PAD  | 00011010 000TDDDD SSPPBBBB BBBBBBBB |        |B,M,C,D,T|         | O = testControls(instr,0)|   O   |        |  test controller buttons    
 |27 / 0x1B | SPD  | 00011011 VVVVVVVV VVVVBBBB BBBBBBBB |  V,B   |         |         |S = B + ((V * fps?) >> 10)|   S   |        |  calculate speed 
 |28 / 0x1C | MSC  | 00011100 TTTTSSSS SLLLXXXX XXXXXXXX |   X    |  T,S,L  |         |     various; see docs    |  ***  |   ***  |  multi-purpose
 |29 / 0x1D | DRS  | 00011101 PPPPPPPP PPPPDDDD DDDDDDDD |  P,D   |         |         |    large calc; see docs  |   O   |        |  driven sine wave
 |30 / 0x1E | PRD  | 00011110 MMMMMMMM MMMMPPPP PPPPPPPP |  M,P   |         |         | O = (M + frameCount) % P |   O   |        |  periodic function
 |31 / 0x1F | RGL  | 00011111 00000000 0000IIII IIIIIIII |   I    |         |         |    O = globals[I >> 8]   |   O   |        |  read global variable
 |32 / 0x20 | WGL  | 00100000 SSSSSSSS SSSSIIII IIIIIIII |  I,S   |         |         |    globals[I << 8] = V   |       |        |  write global variable
 |33 / 0x21 | ANG  |                                     |        |         |         |                          |       |        |  angle between
 |34 / 0x22 | APH  | 00100010 RRRRRRRR RRRRLLLL LLLLLLLL |  L,[R] |         |  S,[R]  |    O = approach(L,R,S)   |   O   |        |  approach a value
 |35 / 0x23 | PLCV |                                     |        |         |         |                          |       |        |
 |36 / 0x24 | WLCV |                                     |        |         |         |                          |       |        |
 |37 / 0x25 | RAPH | 00100101 RRRRRRRR RRRRLLLL LLLLLLLL |  L,[R] |         |  S,[R]  |    O = rotate(L,R,S,0)   |   O   |        |  approach an angle
 |38 / 0x26 | PSHB |                                     |        |         |         |                          |       |        | 
 |39 / 0X27 | ANI  | 00100111 QQQQQQQQ QQQQDDDD DDDDDDDD |   F    |         |         | D=&obj.global.anim[F>>5] |       |   D    |
 |128/ 0x80 | NOP  | 10000000 00000000 00000000 00000000 |        |         |         |                          |       |        |  no operation
 |129/ 0x81 | NOP  | 10000001 00000000 00000000 00000000 |        |         |         |                          |       |        |  no operation
 |130/ 0x82 | ***  | 10000010 TTCCMMMM MMLLLLLL LLLLLLLL |        | T,C,M,L |         |                          |       |        |  general control flow
 |          |  B   | 10000010 0000MMMM MMPPPPLL LLLLLLLL |        |  M,P,L  |         |                          |       |        |  -branch
 |          |  BNEZ| 10000010 0001MMMM MMPPPPLL LLLLLLLL |        |  M,P,L  |         |                          |       |        |  -branch not equal zero
 |          |  BEQZ| 10000010 0010MMMM MMPPPPLL LLLLLLLL |        |  M,P,L  |         |                          |       |        |  -branch equal zero
 |          |  CST | 10000010 0100MMMM MMSSSSSS SSSSSSSS |        |   M,S   |         |                          |       |        |  -change state
 |          |  CSNZ| 10000010 0101MMMM MMSSSSSS SSSSSSSS |        |   M,S   |         |                          |       |        |  -change state not zero
 |          |  CSEZ| 10000010 0110MMMM MMSSSSSS SSSSSSSS |        |   M,S   |         |                          |       |        |  -change state equal zero
 |          |  RET | 10000010 1000MMMM MMLLLLLL LLLLLLLL |        |         |         |                          |       |        |  -return
 |131/ 0x83 | ANIS | 10000011 HHWWWWWW SSSSSSSS SFFFFFFF |        | F,S,W,H |         |                          |   T   |        |  change animation sequence
 |132/ 0x84 | ANIF | 10000100 HHWWWWWW FFFFFFFF FFFFFFFF |   F    |   W,H   |         |                          |   T   |        |  change animation frame
 |133/ 0x85 | VEC1 | 10000101 LLLTTTAA ABBBVVVV VVVVVVVV |   V    | T,A,B,L |         |                          |  ***  |  ***   |  multi-purpose vector calcs
 |134/ 0x86 | JAL  | 10000110 PPPP0000 00LLLLLL LLLLLLLL |        |   L,P   |         |                                           |  jump and link
 |135/ 0x87 | **   |                                     |        |         |         |                                           |  
 |136/ 0x88 | ***  |                                     |        |         |         |
 |137/ 0x89 | ***  |                                     |        |         |         |
 |138/ 0x8A | CHLD | 10001010 AAAATTTT TTTTSSSS SSCCCCCC |        | C,T,S,A |[C]+AxRgs|                          |       |        |  spawn children objects
 |139/ 0x8B | NTRY | 10001011 TTTTTTTT TTTTEEEE EEEEEEEE |        |   T,E   |         |                                           |  multi-purpose pagesys interface
 |140/ 0x8C | SNDA |                                     |        |         |         |                                           |  (adjust audio levels)
 |141/ 0x8D | SNDB |                                     |        |         |         |                                           |  (play audio)
 |142/ 0x8E | VEC2 | 10001110 000TTTAA ABBBVVVV VVVVVVVV |        |         |         |                                           |  multi-purpose vector calcs
 |143/ 0x8F | EVNT |                                     |        |         |         |                                           |  issue an event
 |144/ 0x90 | **   |                                     |        |         |         |                                           |
 |145/ 0x91 | CHDN |                                     |        |         |         |                                           |  spawn children objects
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
Naming schema:

- A
  AAAAAAAAAAAA        = value A
  AAAA                = count of Arguments
  AAA                 = index of vector A

- B
  BBBBBBBBBBBB        = value B
  BBBBBBBBBBBB (PAD)  = primary _buttons to test
  BBBBBBBBBBBB (SPD)  = _base speed
  BBB                 = index of vector _B

- C
  CCCCCCCCCCCCCC      = object _code offset
  CCCCCC              = count of _child objects to spawn
  CC                  = _condition check type
                      
- D                   
  DDDDDDDDDDDD        = _destination operand
  DDDD                = secondary buttons to test (usually _directional?)
  
- E
  EEEEEEEEEEEE        = entry EID
  
- I
  IIIIIIIIIIII        = global variable _index

- J
  JJJJJJJJJJJJ        = progress jump back
  
- L                   
  LLLLLLLLLLLLLL      = destination jump and link _location 
  LLLLLLLLLLLL        = _left operand
  LLL                 = object _link index
                      
- M                   
  MMMMMMMMMMMM        = phase
  MMMMMM              = object memory location
                      
- P                   
  PPPPPPPPPPPP        = length of period
  PPPP                = stack pop count
  PP                  = primary button check type

- Q                   
  QQQQQQQQQQQQ        = animation sequence offset

- S                   
  SSSSSSSSSSSSSS      = new state
  SSSSSSSSSSSS        = source operand
  SSSSS               = [misc] operation subtype
  SS                  = secondary button check type
  
- T
  TTTTTTTTTTTT        = entry operation type
  TTTTTTTT            = child object type
  TTTT                = [misc] operation type
  TTT                 = [vector] operation type
  TT                  = [control flow] operation type
  T                   = truth bit

- V
  VVVVVVVVVVVV        = velocity
  
- X                   
  XXXXXXXXXXXX        = source and dest/inout operand
  
The GOOL instructions table above lists the mnemonic/name, opcode, format, operands (based on 
explicit and/or implicit specification of origin and/or target of source and/or destination), 
general operation (represented mathematically/ with c-style equivalent line of code), and English 
description for all * types of GOOL instructions. 


The mnemonic/name of an instruction is...

A GOOL instruction's opcode determines its specific type of operation; its operands determine 
additional specifics to its operation: sets of 'source' data to operate by and/or sets of 
'destinations' to effectively store the data results of its operation. Thus, an instructions 
operands are divided into two types: 'source operands' (or in-type operands), which describe 
[possibly the -location(s)- of] source data to be used by its operation, and 'destination operands' 
(or out-type operands), which describe the [destination] location(s) at which the operation shall 
store results. 

GOOL Instruction Operand Specification Types
--------------------------------------------

For an instruction with a particular opcode/operation (i.e. of a particular type), its operands are 
'explicitly specified' in its lower 24 bits (operand portion) according to its binary -format-, 
specific to instructions of that type. A particular instruction's format gives its typical binary 
representation: instruction opcode in its upper 8 bits (byte), and bitfields corresponding to each 
of its specific operands in its lower 24 bits (each indicated by a string of the repeated capital 
letter that identifies it). 

Occasionally, for an instruction of a particular type, its operation may require that some of its 
operands are 'implicitly specified' by their prior -push- to the top of the executing object's 
stack. These are not explicitly specified operands because their values are not determined from the 
operand portion of the instruction; these are so called 'implicitly specified' operands because it 
is -implied- that the instruction's operation will effectively pop these operands from their implied 
origin: the object's stack. 

For an instruction of a particular type, each explicitly specified operand is either: a constant 
operand, or a GOOL operand. A constant operand requires that its value be directly specified [in its 
corresponding bitfield of the operand portion of the instruction]; conversely, a GOOL operand is to 
be specified in a particular format: the operation of the instruction must first 'translate' the 
operand to its corresponding translated value prior to its use. A GOOL operand can be translated to 
yield, among several other types of pointers, a pointer to any of an object's fields; this pointer 
is then used by an operation to -read the data- at its [implied] 'source location' and/or to -write 
data- at its implied 'destination location', deeming the operand a GOOL source operand and/or a GOOL 
destination operand, respectively. A GOOL operand can also be translated to yield a pointer to the 
value at the top of the objects stack for, -before- either decrementing or incrementing its stack 
pointer, a location that can be dereferenced for a read or write, effectively popping or pushing its 
stack [based on whether the operation expects the operand to be a GOOL source operand or a GOOL 
destination operand]. In these cases, the instruction operand, is said to be explicitly popped off 
or pushed onto the objects stack. 

For a majority of GOOL instructions' operations, the net effect involves an 'implicit push' of 
operation results to the object's stack. 

Thus, operations of GOOL instructions may expect operands of several different [compound] 
'specification types'; the following are characteristics of each specification type: 

  - in/source type operands -

    - explicitly specified (i.e. origin = determined by operand's corresponding bitfield from operand portion of instruction)
      i.)   GOOL [source] operand
      ii.)  constant operand
      
    - implicitly specified (i.e. origin = top of object's stack; implicitly popped from top of object's stack)
      iii.) stack [source] operand

  - out/destination type operands -
      
    - explicitly specified (i.e. target = determined by operand's corresponding bitfield from operand portion of instruction)
      iv.)  GOOL [destination] operand
      
    - implicitly specified* (i.e. target = top of object's stack; implicitly pushed to top of object's stack)
      v.)   stack [destination] operand/result*
      
      *technically not an 'operand', rather a -result- of the instruction's overall operation; it is 
      -implied- that the net effect of the operation for an instruction that 'uses [an] operand(s)' of 
      this spec. type always pushes it/them (i.e the result(s)) to the top of the object's stack. 
      
Operands for a few instructions are said to have 'compound' specification types; for example, 
operand 'X' for instruction PRW is used as a GOOL source operand -and- a GOOL destination 
operand-that is, the source data referenced by the pointer yielded from its translation is 'mutated' 
by the instruction's operation, or is used by the operation as source data and is effectively 
rewritten (since the translated destination operand refers to the same location). In other cases 
some operands appear [for instructions in the table] to be both an explicitly specified type and an 
implicitly specified type; actually, none can be both-as it turns out, an operands explicit 
specification will take -precedence- over its implicit specification so long as that [GOOL] 
operand's translation does not evaluate to 'false'. Some operands can also be 'optionally' specified 
for particular instructions, where either a default value or that from an implicit pop is used in 
place when their translation evaluates to false. 

....
out type operands - By the operation of some specific type of instruction that requires some 
out-type operand to be specified, data will ultimately be written to [the unsigned long of memory 
at] that operand's 'translated location'. Such data is an expected result of that specific type of 
[instruction's] operation. By the operation of an instruction with specific type/opcode that must 
specify multiple out-type operands, its corresponding expected result(s) will ultimately be written 
at the respective translated location(s) for each specified operand. 


GOOL operand translation
------------------------

111000011111 - object stack [pop/push]

111AAAAAAAAA - object field/memory (A != 0x1F) 

110BBBAAAAAA - link object field 

00AAAAAAAAAA - object global   executable bytecode
01AAAAAAAAAA - object external executable bytecode

100AAAAAAAAA - constant mult of 16  (range: -8192  - 8176) 
1010AAAAAAAA - constant mult of 256 (range: -32768 - 32512)

10110AAAAAAA - object frame argument/local variable [peek stack @ location relative to fp]

10111110**** - 'false' constant (translates to 0)
10111111**** - 'true'  constant (translates to 1)


Given an instruction with specific type/opcode whose operation expects the [explicit] specification 
of at least one GOOL operand (i.e. at least one operand listed in table under explicit GOOL ops in 
and/or explicit GOOL ops out for that instruction type/opcode), and with a specific one of its GOOL 
operands specified as a particular sequence of bits in its corresponding bitfield (12 bit region) 
within the operand portion of the instruction, the following can be used to determine, in that 
instruction's operation, the specific steps taken for the necessary translation of that operand to 
its pointer of a specific type. When specified as some particular sequences of bits, the operand's 
translation can result in a different operation based on whether the instruction table lists that 
operand [for the accompanying instruction type/opcode] as an 'in' or an 'out' type GOOL operand. 

i.) 111000011111 - object stack [pop/push]


in  - in-type operands of this bit sequence will return a pointer to the top of the object's stack/stack 
pointer prior to popping the value there/decrementing the object's stack pointer. A stack pop will 
result from the translation's decrementing of the object's stack pointer and the operation's 
dereferencing of the returned/translated pointer for a read; this popped value is then used by the 
operation as the operand's actual/translated value. 

out - out-type operands of this bit sequence will return a pointer to the top of the object's stack/stack 
pointer prior to its extension/incrementing the object's stack pointer. A stack push will result 
from the translation's incrementing of the object's stack pointer and the operation's dereferencing 
of the returned/translated pointer for a write. The data written at the location of a returned 
pointer/pushed to the stack by an instruction's operation is an expected result of the specific type 
of operation. 

-- 

ii.) 111AAAAAAAAA - object field/memory (A != 0x1F) 

A = object field index (domain = 0    to 0x1FF; 
                         range = 0x60 to 0x860, R=4N) 

                         
A significant amount of an object's fields lie within its 'process' structure; this structure is 
located at a 0x60 byte offset from the beginning of the object's structure. Note that the last of 
the fields in the object's process structure also includes its array of/address space for its 
[local] memory where its stack contents are stored. 

Operands of the bit sequence 111AAAAAAAAA will return a pointer to the 'A'th object field in 
relation to an object's process structure; because object fields are 4 bytes/an unsigned long in 
length and an object's process structure is located at a 0x60 byte offset from the beginning of its 
structure, then the formula: 

  0x60 + (A * 4) 

gives the byte offset of the actual field pointed to by the translation's returned pointer, and 
consequently the actual field referred to by such an operand. The object structure definition listed 
in previous sections includes byte offsets for all object fields within the object structure. 

Notice that if A [bits] is specified as A = 0x1F, then the bit sequence will have the form 
111000011111; this is, however, the bit sequence whose translation shall instead be processed for a 
stack pop/push. If, however, such a sequence were not checked and ultimately processed for a stack 
pop/push prior to passing the test for the bit sequence 111AAAAAAAAA with A = 0x1F, then the byte 
offset determined by translation of such an operand- 0x60 + (A * 4) = 0x60 + (0x1F * 4) = 0xDC = 
byte offset of object's 'stack pointer' field -would refer to the object's stack pointer field. As 
this is arguably a favourable design choice, it should not be possible to directly modify an 
object's stack pointer field via translation of specified operands-only indirectly, should the 
translation of an such an instruction's GOOL operand when specified in the form 111000011111 
[111AAAAAAAAA with A = 0x1F] modify the object's stack pointer as a result of the appropriate push 
and/or pop. 


in - in-type operands of this bit sequence will return a pointer to the corresponding object field; 
this value is then used by the operation as the operand's actual/translated value. 

out - out-type operands of this bit sequence will return a pointer to the corresponding object 
field. Data will ultimately be written to this location as an expected result of the specific type 
of operation. 

--

iii.) 110BBBAAAAAA

A = [link] object field index (domain =     0 to  0x3F;
                               range  =  0x60 to 0x15C, R=4N)

B = object link index         (domain =     0 to 7;
                               range  =  0x60 to 0x7C,  R=4N)  
                                         
Operands of the bit sequence 110BBBAAAAAA will return a pointer to the 'A'th' object field in 
relation to the object's 'B'th' link object's process structure. An object's 'link objects' are 
referred to by the 8 object pointers at the beginning of its process structure; the first of these 
pointers is the object's 'self link', the second a pointer to its parent object, the third a pointer 
to its sibling object, and so on. The A bits in the sequence specify the offset of a field in 
unsigned longs from the link object's process structure; the B bits in the sequence specify the 
index of one of the object's 8 link objects that contains the process structure which the returned 
object field pointer's location will be calculated relative to. Thus, translation of such a bit 
sequence will return a pointer to any of an object's link object's process structure's fields. 


in - in-type operands of this bit sequence will return a pointer to the corresponding object field; 
this value is then used by the operation as the operand's actual/translated value. 

out - out-type operands of this bit sequence will return a pointer to the corresponding object 
field. Data will ultimately be written to this location, where such data is an expected result of 
some specific type of [instruction's] operation. For an instruction that can specify multiple 
out-type operands (with specific type/opcode), by the instruction's operation, its corresponding 
expected result(s) will ultimately be written at the respective translated location(s) for each 
operand specified in this format/with this bit sequence. 

--
 
iv.) 00AAAAAAAAAA - object global executable static data

A = object executable static data offset (domain =   0 to 0x3FF;
                                          range  =   0 to 0xFFC, R=4N)

A GOOL executable's static data (GOOL_data) item is essentially a table of static, predefined 
'magic' constants that can be used by GOOL operations as the translated values of operands with this 
bit sequence. For example, it includes the EIDs of any entries, preconfigured bitfields, values 
corresponding to specific bits to test, audio sample parameters (volume, pan, etc), specific speeds 
or velocities, and other constants utilized by the operations of instructions in the executable's 
GOOL_code item. It is necessary that a translation can yield these constants for the values of some 
GOOL operands since, as it will be seen, the only other types of translation that can yield a 
specific constant are restricted to yielding constants in certain ranges. 

[Also, in the case that the bit sequence types for the latter translation can be used in operands, 
if the operations for instructions [with the operands] translate them to the same constant [i.e. the 
same bit sequence is specified for the operands in each instruction] and utilize that constant in 
the same fashion, then if an equal change in those operations is desired as some modification during 
development it would generally involve changing the specified sequence for -each- operand in each 
instruction. Then, it is beneficial to keep a table of constants, since the translations for 
different instructions' operands that yield a reference the same constant in the table will, when 
changing the single unsigned long/constant in the table, reference the same -changed- constant in 
the table.] 

Operands of the bit sequence 00AAAAAAAAAA will return a pointer to the static, predefined constant 
at the offset specified by 'A bits' within/relative to the object's global GOOL executable entry's 
static data [item]; that is-a translation of this type will return a pointer to the constant at an 
offset of 'A' unsigned longs relative to the third (static data) 'item' (unsigned long array) within 
the entry structure referred to by the objects 'global' field. 


in - in-type operands of this bit sequence will return a pointer to the corresponding location in 
the object's global executable [entry's] static data [item]; the unsigned long/constant at this 
location is then used by the operation as the operand's actual/translated value. 

out - out-type operands of this bit sequence will return a pointer to the corresponding location in 
the object's global executable [entry's] static data [item]; the operation ultimately replaces the 
constant at this location with its respective unsigned long result (designated for the translated 
location of that operand.) A write to the executable's static data should generally be avoided 
unless a global change to that constant, and therefore an equal change in behavior for each object 
that is an instance of that executable, is desired. 

--

Note the distinction from the object's 'global' GOOL entry from it's 'external' GOOL entry. The 
global entry may or may not contain the byte code [item] that will be interpreted in the object's 
current state; it contains the corresponding state definition that specifies the GOOL executable 
entry which contains the actual GOOL byte code item with the instructions that will be interpreted. 
In the object's current state, its 'external' entry will refer to that specified entry. 

--
v.) 01AAAAAAAAAA - object external executable static data

A = object executable static data offset (domain =   0 to 0x3FF;
                                          range  =   0 to 0xFFC, R=4N)

Operands of the bit sequence 01AAAAAAAAAA will return a pointer to the constant (unsigned long) at 
the offset specified by 'A bits' within/relative to the object's external GOOL executable entry's 
static data [item]; that is-a translation of this type will return a pointer to the constant at an 
offset of 'A' unsigned longs relative to the third (static data) 'item' (unsigned long array) within 
the entry structure referred to by the objects 'external' field. 


in - in-type operands of this bit sequence will return a pointer to the corresponding location in 
the object's external executable [entry's] static data [item]; the unsigned long/constant at this 
location is then used by the operation as the operand's actual /translated value. 

out - out-type operands of this bit sequence will return a pointer to the corresponding location in 
the object's external executable [entry's] static data [item]; the operation ultimately replaces the 
constant at this location with its respective unsigned long result (designated for the translated 
location of that operand.) A write to the executable's static data should generally be avoided 
unless a global change to that constant, and therefore an equal change in behavior for each object 
that is an instance of that executable, is desired. 
--
  
vi.) 100AAAAAAAAA - constant mult of 16 

A = constant that will be multiplied by 16 (domain:      0 to  0x1FF)
                                           ( range:  -8192 to   8176; R =   16N)
                                      << 4 (       -0x2000 to 0x1FF0; R = 0x10N)
                                           
Operands of the bit sequence 100AAAAAAAAA will return a pointer to a value that is written as one of 
two double-buffered signed long 'constants' in their 2 respective buffers located at offsets 0x40 
and 0x44 in scratch memory, as referenced by the pointer at memory location 0x56480 [gp$(0x44)]. 
Translation for operands of this bit sequence will first write the value (16*A)-that is, 16 times 
the value specified by 'A bits'-to the 'currently active constant buffer'. The currently active 
constant buffer is indicated by either a 0 or a 1 in the unsigned long at memory location 0x56484 
[gp$(0x48)], which refers to either the buffer at offset 0x40 or 0x44, respectively, in scratch 
memory. The currently inactive constant buffer at any instant is always the buffer that is NOT the 
currently active constant buffer. The translation then proceeds by changing the currently inactive 
constant buffer to the currently active constant buffer (that is, if 0 previously indicated the 
currently active constant buffer, then this is changed to a 1; conversely, if 1, it is changed to a 
0). The translation finally returns a pointer to the (16*A) signed long value that had been written 
to the previously active buffer, at which point is the currently inactive buffer. 
                          
The double-buffering design allows the sufficient specification of a maximum of 2 (constant) GOOL 
operands [with this bit sequence] per instruction, since each of the 2 buffers will keep track of 1 
and therefore an overall of 1+1=2 [translated] constants to be used by operations of instructions 
with the corresponding operands. 

A can be specified as a negative constant with the appropriate 2's complement format: 

A = 1NNNNNNNN (-N): V = 11111111111111111111NNNNNNNN0000 (16 * -N)
A = 0NNNNNNNN ( N): V = 00000000000000000000NNNNNNNN0000 (16 *  N)

Where V indicates the binary signed long that will be written to the appropriate constant buffer for 
the respective specified formats of A. 


in - in-type operands of this bit sequence will return a pointer to the [currently inactive constant 
buffer after storing the] appropriate constant value (A * 16) [in the active constant buffer and 
changing the active constant buffer to the currently inactive constant buffer]; the unsigned 
long/instruction at this location is then used by the operation as the operand's actual/ translated 
value. 

out-type operands of this bit sequence are useless: they will return a pointer to the currently 
inactive constant buffer after storing the appropriate constant value (A * 16) in the active 
constant buffer and changing the active constant buffer to the currently inactive constant buffer, 
and that stored constant value in the [then currently] inactive constant buffer will ultimately be 
overwritten by the corresponding expected result of the operation. However, since the data in the 
constant buffer can be only accessed by translation of operands with this bit sequence, which 
involves the prior overwriting of the active constant buffer with (A*16), then that result can never 
be accessed [without first being overwritten]. 

--

vii.) 1010AAAAAAAA - constant mult of 256 

A = constant that will be multiplied by 256 (domain:      0 to   0xFF)
                                            ( range: -32768 to  32512; R =   256N)
                                       << 8 (       -0x8000 to 0x7F00; R = 0x100N)
                                            
Operands of the bit sequence 1010AAAAAAAA are translated almost identically to those of bit sequence 
type vi; the only difference is in the calculation for the constant written to the respective 
buffer: 

A = 1NNNNNNN (-N): V = 1111111111111111NNNNNNNN00000000 (256 * -N)
A = 0NNNNNNN ( N): V = 0000000000000000NNNNNNNN00000000 (256 *  N)

Where V indicates the binary signed long that will be written to the appropriate constant buffer for 
the respective specified formats of A. 

in - in-type operands of this bit sequence will return a pointer to the [currently inactive constant 
buffer after storing the] appropriate constant value (A * 256) [in the active constant buffer and 
changing the active constant buffer to the currently inactive constant buffer]; the unsigned 
long/instruction at this location is then used by the operation as the operand's actual/ translated 
value. 

out-type operands of this bit sequence are useless for the same reasons those of sequence type vi 
are. 

--

viii.) 10110AAAAAAA - object frame argument/local variable [peek stack @ location relative to fp]

A = argument/local variable offset, relative to object FP (domain =      0 to 0x7F)
                                                          (range  = -0x100 to 0xFC, -40 args to +39 local vars)

Immediately prior to creating a new stack frame for the object, whether it be the initial stack 
frame [recreated due to a state change], the frame for a non-code thread, or the frame created for a 
linked subroutine, a number of 'arguments' [for the new frame] can be pushed to the object's stack 
to occupy the locations that will immediately precede that of the new frame. And, after the frame is 
created, with further interpretation, the results of operations are pushed to the object's stack to 
extend that frame; usually, these results will have a particular, expected order on the object's 
stack based on the expected results of the operations for the interpreted sequence of instructions. 
Then, conceptually, these results are said to be the contents of 'local variables' within that stack 
frame. 

Operands of the bit sequence 10110AAAAAAA will return a pointer to the [unsigned long/data at the] 
location on the object's stack of the data that is 'A' unsigned longs/units of data (4*A bytes) 
relative to the object's current frame pointer. Typically, A is specified as a negative value/offset 
when a pointer to some argument is desired; this is because the arguments are located -before- the 
start of the stack frame. A is specified as a positive offset (>3) when a pointer to some local 
variable (i.e. operation result) is desired. 

A can be specified as a negative offset with the appropriate 2's complement format: 

A = 1NNNNNN (-N): O = 111111111111111111111111NNNNNN00 (4 * -N)  (argument offset)
A = 0NNNNNN ( N): O = 000000000000000000000000NNNNNN00 (4 *  N)  (local variable offset)


in - in-type operands of this bit sequence will return a pointer to the [unsigned long/data at the] 
location on the object's stack of the data that is 'A' unsigned longs/units of data (4*A bytes) 
relative to the object's current frame pointer. The value at this location is then used by the 
operation as the operand's actual/translated value. 

out - out-type operands of this bit sequence will return a pointer to the [unsigned long/data at 
the] location on the object's stack of the data that is 'A' unsigned longs/units of data (4*A bytes) 
relative to the object's current frame pointer. Data will ultimately be written to this location as 
an expected result of the specific type of operation, overwriting either the argument or local 
variable [at that location]. 
--

ix. 10111110**** - 'false' constant (translates to 0)
   (101111100000 = 0xBE0)
 
Operands of the bit sequence 10111110**** (where * indicates the possibility of either a 1 or 0) 
will, rather than return a pointer to some memory location, return the value 0 (i.e. invalid pointer 
to memory location 0). When specified, operands of this bit sequence will cause the operations of 
most instructions to return without writing/storing any results or making any calculations. 

For a few other instructions, operands of the sequence will cause the operations to 'implicitly' pop 
a number of additional operands from the object's stack. For the few other instructions, prior to [a 
potentially worthless] translation of some operand, if the operand has been specified in the format 
0xBE0 (i.e. the usual specification for this sequence), its translation will be skipped. Then, in 
exchange for the lack of a translated value for that operand, its value, and possibly the values for 
a number of additional operands [depends on the particular instruction's operation], will instead be 
popped off of the object's stack. The additional operands will then be factored in an alternative, 
extended calculation for that instruction by the operation. Usually, rather than having to 
alternatively perform some extended calculation, when the operand is -not- specified in this format, 
the operation -sets- default values for each of the 'additional operands'. The same specific 
calculations will be performed in the operation for the instruction, factoring in the same operand 
values [including those of the 'additional operands'], but the default values set for the additional 
operands can be 'overridden' with the specification of this bit sequence for the operand that would 
cause an implicit popping of their values from the object's stack. 


in  - in-type operands of this bit sequence will return a null pointer (pointer to memory location 
0). If specified, when translated by the operation for most instructions, the remainder of the 
operation will be skipped. For few other instructions the translation for an operand of this 
specific sequence will be skipped; this is followed with a pop of the actual value for that operand 
and a potential pop of the [overriding] values for an additional number of operands that could 
otherwise not be explicitly or implicitly specified for the resolution of their values, which 
therefore are otherwise directly set to some instruction-specific defaults. 

out-type operands of this bit sequence will return a null pointer; a trap will result with the 
attempt to access the memory at that location (0), which lies in the kernel code segment. Out-type 
operands should therefore not be specified with this bit sequence. 

--

x.  10111111**** - 'true' constant (translates to 1)
   (101111110000 = 0xBF0)
   
Operands of the bit sequence 10111111**** (where * indicates the possibility of either a 1 or 0) 
will, rather than return a pointer to some memory location, return the value 1 (i.e. invalid pointer 
to memory location 1). When specified, operands of this bit sequence will cause the operations of 
most instructions to trap the system; this is due to their attempt to access the memory at the 
operands translated 'location' (1), which lies in the kernel code segment. 

For a few other instructions, operands of the sequence will cause the operations to alternatively, 
implicitly pop a number of additional operands from the object's stack, just like described for 
those of sequence type ix. However, the difference in sequence type x from type ix is that only the 
operations for a completely different, disjoint set of instructions exhibits this behavior-that is, 
operations for only some instructions will behave this way when the operand is specified as 0xBE0; 
conversely, operations for only some other instructions will behave this way when the operand is 
specified as 0xBF0. 

To better understand this behavior, consider the instruction PRW: when its explicitly specified 
operand J is specified with any bit sequence type other than type xi or x, the instruction's 
operation will appropriately translate that operand to resolve its actual value; its operand I 
(which at that point cannot be directly or indirectly specified by the instruction itself) will then 
take on a default value of 0x100. The operation will then perform all the appropriate calculations 
with those operand values, ultimately storing one result to the translated location of operand X and 
pushing another result P to the object's stack. However, when its explicitly specified operand J is 
specified with bit sequence type x (i.e. BF0), the instruction's operation will instead: skip 
translation of operand J, implicitly pop the value for operand I off of the object's stack, and 
resolve operand J's value by additionally [implicitly] popping it off the object's stack. The 
operation will then perform all the appropriate calculations with -those- operand values. 

Thus, the '[]' brackets around an explicit GOOL operand for an instruction in the table indicate 
that, when specified in one format of either sequence type ix or x (i.e. 0xBE0 or 0xBF0) but not the 
other, the instruction's operation performs differently: that same operand and any additional 
operands if '[]' bracketed and listed under implicit STACK operands (for the instruction in the 
table) will instead have their values popped off of the object's stack in the order of their 
listing. When the explicitly specified operand is -not- of bit sequence type ix or x, the 
alternative is to resolve its value by translation, and the values of any 'additional' operands that 
would have otherwise been popped off the object's stack are instead set to the corresponding 
'default' values as indicated under explicit constant operands for the instruction in the table. 


in - in-type operands of this bit sequence for a few instructions will skip their translation; this 
is followed with a pop of the actual value for that operand and a potential pop of the [overriding] 
values for an additional number of operands that could otherwise not be explicitly or implicitly 
specified for the resolution of their values, needing to be directly set to some instruction- 
specific defaults. When translation is not skipped, as in the operations of most other instructions, 
this bit sequence will return an invalid pointer (pointer to memory location 1). When specified, 
operands of this bit sequence will cause the operations of most instructions to trap the system; 
this is due to their attempt to access the memory at the operands translated 'location' (1), which 
lies in the kernel code segment. 

out-type operands of this bit sequence will return an invalid pointer; a trap will result with the 
attempt to access the memory at that location (1), which lies in the kernel code segment. Out-type 
operands should therefore not be specified with this bit sequence. 

--

...

--
* where an operand's 'value' is defined as the value referred to by the pointer resolved from its 
translation.

GOOL instruction operation details
----------------------------------

0x00) ADD 
---------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, the sum of their values is computed (O = L + R); this sum is 
then pushed to the object's stack. 

additional:

L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


0x01) SUB 
---------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, the difference of their values is computed (O = L - R); this 
difference is then pushed to the object's stack. 

additional:

L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


0x02) MUL 
---------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, the product of their values is computed (O = L * R); this 
product is then pushed to the object's stack. 

additional:

O is the lower 32 bit result of multiplication (i.e. r3000a MFLO) 
L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


0x03) DIV
---------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, the quotient of their values is computed (O = L / R); this 
quotient is then pushed to the object's stack. 

additional:

O is the lower 32 bit result of division (i.e. r3000a MFLO)
R must not translate to reference '0'; otherwise, an attempt to divide by 0 will trap the system. 
L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


0x04) CEQ
---------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, their values are tested for equality (O = (L == R)); the 
result of the test (0 = false, 1 = true) is then pushed to the object's stack. 

additional:

The actual test for equality is the assembly equivalent of "O = ((L ^ R) == 0)". 
L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


0x05) ANDL
----------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, their values are logically anded (O = (L && R)); the result 
of the logical and operation (0 = false, 1 = true) is then pushed to the object's stack. 

additional:

The actual process of the logical and is the assembly equivalent of "O = (L ? (R > 0) : 0)". 
L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


0x06) ORL
---------
format: 00000000 RRRRRRRR RRRRLLLL LLLLLLLL

GOOL operands (in): L,R  
STACK out: O  

operation:

After translation of operands L and R, their values are logically ored (O = (L || R)); the result of 
the logical or operation (0 = false, 1 = true) is then pushed to the object's stack. 

additional:

The actual process of the logical or is the assembly equivalent of .....TODO
L or R must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


TODO
.....
------

0x16) PSH
---------
format: 00010110 AAAAAAAA AAAABBBB BBBBBBBB

GOOL operands (in): A,B  
STACK out: [A,[B]]  

operation: 

After translation of operand A, the value at its pointed location is pushed to the object's stack. 
The operation then proceeds with translation of operand B: if operand B's resolved pointer is 
nonzero, then the value at its pointed location is pushed to the object's stack. 

additional:

-If A is specified as false (0xBE0), the operation does nothing.
-If A is specified such that its translation will yield a valid pointer, and B is specified as false 
 (0xBE0), only a single value will be pushed to the object's stack: the value at A's translated 
 location. 
-If both A and B are specified such that their translations will yield valid pointers, then two 
 values will be pushed to the object's stack: the value at A's translated location followed by the 
 value at B's translated location. 
-A or B must not be specified as true (0xBF0); doing so will trap the system.

applications:

-pushing arguments for subroutines (i.e. 'jumped and linked' blocks)
-local variable creation

--

TODO
......
------
 
0x1C) MSC
---------
format: 00011100 TTTTSSSS SLLLXXXX XXXXXXXX

GOOL operands (inout): 
X = multi-purpose source or destination

constant operands: 
T = operation type       (domain/range: 0 to   15)
S = multi-purpose        
L = multi-purpose index  (domain:       0 to    7)

operation:

After translation of GOOL [inout] operand X, the value of constant operand T is used to determine 
the specific 'type' of MSC operation to perform. There are 15 types of MSC operations: 

[the following operations consider that X has already undergone translation]
............................................................................
(T = 0) type 0 - dereference
----------------------------
format: 00011100 0000SSSS S***XXXX XXXXXXXX

GOOL operands (used as in):
X = address value        (i.e. translation will have yielded a pointer to a value that is the address/location of yet 
                          another pointer)
constant operands:
S = address offset       (domain: 0 to 0x20  range: 0 to 0x80, R=4N) 

STACK out: 
O = dereferenced value or 0

operation:

If X's translated address value is nonzero, the [game] memory at location "X + (S*4)" is 
dereferenced and the value is pushed to the object's stack; otherwise a 0 is pushed to the object's 
stack. 

additional:

-If X is specified as false (0xBE0), the operation does nothing.
-X must not be specified as true (0xBF0); doing so will trap the system.

applications:

-Reading arguments passed with an issued GOOL event from within its thread of interpretation.


(T = 1) type 1 - distance from vector to object translation vector
------------------------------------------------------------------
format: 00011100 0001***S SLLL**** ********

constant operands:
S = operation mode flags (000YA: Y (set) = disregard Y coordinate
                                 A (set) = calculate actual euclidean distance (rather than approximate))
L = object vector index  (domain: 0 to 7 range: 0x80 to 0x9C, R=4N*)

STACK out: 
O = dereferenced value or 0

operation:

The operand L determines the index of one of the object's vectors; the euclidean distance from that 
vector to the object's translation vector is to be computed. If the Y flag is set, both vectors are 
first copied to temp/stack where their Y coordinates are replaced with 0-otherwise, both vectors are 
used directly. If the A flag is set, pointers to both vectors are passed to the 'euc_dist' routine, 
which calculates the euclidean distance between them; otherwise pointers to both vectors are passed 
to the 'apx_dist' routine, which calculates the 'approximate' distance between them. The calculated 
distance-O-is then pushed to the object's stack. 

additional:

-Object vectors are 12 bytes in size. The first 3 of an object's vectors that span the address range 
0x80 to 0x9C [relative to its structure] are at locations 0x80, 0x8C, and 0x98, respectively; 
unexpected behavior may result if operand L is not specified so as to yield an offset aligned with 
one of these vectors. 

(T = 2) type 2 - angle from object translation vector to object link translation vector
---------------------------------------------------------------------------------------
format: 00011100 0010**** *LLL**** ********

constant operands:
L = object link index  (domain: 0 to 7 range: 0x60 to 0x7C, R=4N)

STACK out: 
O = calculated angle

operation:

Bits 10 and 22 of the object's statusB flags are checked to determine the object's 'plane of 
orientation'. If either are set, the object is oriented in the XY plane; otherwise, the object is 
oriented in the XZ plane. The operand L determines the index of one of the object's link objects; 
then, based on the object's plane of orientation, either the routine 'ang_XY' or the routine 
'ang_XZ' is called with the object's translation vector and the object's link object's translation 
vector as arguments. Using these arguments, the respective routine will then return the angle 
between the object and its link object in its respective plane of orientation. This angle is then 
pushed to the object's stack. 

additional:
-The object's link at index L must reference a valid object.


(T = 3) type 3 - read link object field/memory
----------------------------------------------
format: 00011100 0011**** *LLLXXXX XXXXXXXX

GOOL operands:
X = [link] object field index *(in upper 24 bits)

constant operands:
L = object link index  (domain: 0 to 7 range: 0x60 to 0x7C, R=4N)

STACK out: 
O = value read

operation:

The operand L determines the index of one of the object's link objects. The upper 24 bits (X >> 8) 
of operand X's value determine the index of the link object's field (*relative to process structure) 
whose value is to be read. The field's value is then read and pushed to the object's stack. 

additional:
-The object's link at index L must reference a valid object.
-X must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.
-X's value may refer to an index that lies within the range spanning the [link] object's [array of] 
 memory. 
-The [link] object field index/offset is likely determined from X's value's upper 24 bits due to its 
 most appropriate specification type (vii, mult of 256, << 8), where in its translation the specified 
 constant A is shifted to the upper 24 bits/multiplied by 256 to yield [X's] value (active constant 
 buffer replacement value). 


(T = 4) type 4 - write to link object field/memory
--------------------------------------------------
format: 00011100 0100**** *LLLXXXX XXXXXXXX

GOOL operands:
X = [link] object field index *(in upper 24 bits)

constant operands:
L = object link index  (domain: 0 to 7 range: 0x60 to 0x7C, R=4N)

STACK in: 
I = value to write

operation:

The operand L determines the index of one of the object's link objects. The upper 24 bits of operand 
X's value determine the index of the link object's field (*relative to process structure) whose 
value is to be replaced. The value I is then [implicitly] popped off of the object's stack and 
written to the link object's field. 

additional:
-The object's link at index L must reference a valid object.
-X must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.
-X's value may refer to an index that lies within the range spanning the [link] object's [array of] 
 memory. 
-The [link] object field index/offset is likely determined from X's upper 24 bits due to its most 
 appropriate specification type (vii, mult of 256, << 8), where in its translation the specified 
 constant A is shifted to the upper 24 bits/multiplied by 256 to yield [X's] value (active constant 
 buffer replacement value). 
 
....


(T = 7) type 7 - find object with PID
-------------------------------------
format: 00011100 0111**** ****XXXX XXXXXXXX

GOOL operands:
X = PID of object to find

STACK out: 
O = found object [pointer] or 0

operation:

The upper 24 bits of an object's PID determines the index of its 'local spawn state bits' in the 
'states' array of the GOOL namespace. If the object specified by PID X does not have bit 1 
(spawned?) set in its spawn bits (states[(X>>8)*4] & 1), then the operation completes by simply 
pushing a 0 to [this] object's stack; otherwise, the operation proceeds to locate that object 
*descendant of the first 5 root group objects* which has X as its PID: 

-This is accomplished with a call to the object [pointer] or null pointer returning recursive routine 
 '... (TODO NAME)' for each child object of each of the first 5 root groups, until for some object 
 the routine returns a non-null object pointer: the routine calls a specified boolean returning 
 routine-in this case a routine that checks if an object has some PID/has its PID field set to some 
 value [X in this case]-for each of the object's descendant object's until either returning the first 
 descendant for which the routine returns true or returning 0 after for no descendant the routine has 
 returned true. 

When some descendant object is found to have X as its PID, or equivalently, as soon as '...(TODO 
NAME)' returns a [non-null] object for some child object of one of the first 5 root groups, the 
descendant object is pushed to [this] object's stack, thus completing the operation. If no 
descendant object is found to have X as its PID, or equivalently, '... (TODO NAME)' never returns a 
[non-null] object for any of the child objects of any of the first 5 root groups, a 0 is pushed to 
[this] object's stack to complete the operation. 

additional:
-If X is specified as false (0xBE0), the operation does nothing.
-If X's value is 0 (an invalid PID), the operation does nothing.
-X's value must otherwise be a valid PID; if not, unpredictable behavior may ensue.
-X must not be specified as true (0xBF0); doing so will trap the system.
-A 0 is pushed to the object's stack if the object with specified PID does not have (spawned?) bit 1 set in its spawn bits
 or could not be found as a descendant of any of the first 5 root group objects.


(T = 8) type 8 - set or clear object 'no respawn' bit (spawn state bit 2)
-------------------------------------------------------------------------
format: 00011100 1000SSSS S***XXXX XXXXXXXX

GOOL operands:
X = PID of object with spawn state bit to modify

constant operands:
S = set/clear flag (0 = set; >0, 1 = clear)
    
operation:

The upper 24 bits of an object's PID determines the index of its 'local spawn state bits' in the 
'states' array of the GOOL namespace. If the value specified by operand S is 0, the 'no respawn bit' 
(bit 2) within the spawn state bits for the object specified by PID X is set by the operation; if 
the value specified by operand S is nonzero (ex. 1), the bit is instead cleared. 

additional:
-If X's value is 0 (an invalid PID), the operation does nothing?????**
-X must not be specified as true (0xBF0) or false (0xBE0); doing so will trap the system.


(T = 9) type 9 - set link object zone to the neighbor zone that contains a point
--------------------------------------------------------------------------------
format: 00011100 1001**** *LLLXXXX XXXXXXXX

GOOL operands:
X = point/vector

constant operands:
L = object link index  (domain: 0 to 7 range: 0x60 to 0x7C, R=4N)

operation:

The operand L determines the index of one of the object's link objects. The current zone is passed 
along with the point X in a call to the 'findZone' routine; if a zone is found/the routine returns a 
valid zone [pointer] then the link object's 'zone' field is set to [point to] that zone. If the 
routine does not find a zone, then the operation accomplishes nothing. 

additional:
-The object's link at index L must reference a valid object.
-X must not be specified as true (0xBF0); doing so will trap the system.
-If X is specified as false (0xBE0) and the current zone is a non-null zone [pointer], the operation 
 will instead set the link object's 'zone' field to [point to] the current zone. 
-If X is specified as false (0xBE0) and the current zone is a null zone [pointer], the operation 
 accomplishes nothing. 
-X must otherwise translate to reference a valid point/vector [i.e. a pointer to the first of 3 
 contiguous signed longs that define the coordinates of a 3 dimensional point]. 


(T = 10) type 10 - (various) spawn state bit set/clear operations
-----------------------------------------------------------------
format: 00011100 1010SSSS S***XXXX XXXXXXXX

constant operands:
S = operation subtype  (     domain/range: 0 to 31,
                        operational range: 0 to 9)

GOOL operands:
X = PID of object with spawn state bit to modify

operation:

The upper 24 bits of an object's PID determines the index of its 'local spawn state bits' in the 
'states' array of the GOOL namespace. The operation modifies the spawn state bits for the object 
specified by PID X, performing a specific modification based on the operation subtype S. The 
following describes the specifics of bit modification for each operation subtype: 

------------------------------------------------------------------------------------
| subtype S = |                           modification                             |                          
------------------------------------------------------------------------------------
|      0      |  clears the ? bit (bit 3)                                          |
|      1      |  sets   the ? bit (bit 3)                                          |
|      2      |  clears the level transition preservation bit (bit 4)              |
|      3      |  sets   the level transition preservation bit (bit 4)              |
|      4      |  clear object's global spawn state bit listing for current level   |
|      5      |  create object's global spawn state bit listing for current level  |
|      6      |  no operation                                                      |
|      7      |  no operation                                                      |
|      8      |  clears the 'exists/spawned' bit (bit 1)                           |
|      9      |  sets   the 'exists/spawned' bit (bit 1)                           |
------------------------------------------------------------------------------------

TODO: explain operation subtypes 4 and 5 and the level/global spawn state bit listings

additional:
-If X is specified as false (0xBE0), the operation does nothing.
-X's value must be a valid PID; if not, unpredictable behavior may result.
-X must not be specified as true (0xBF0); doing so will trap the system.
-For subtype 4 or 5, if the current zone is not a 'state-saving' zone (see section on zones), 
 the operation does nothing.
-If S's value is outside of the operational range, the operation does nothing.
...

(T = 11) type 11 - (various) spawn state bit read operations
------------------------------------------------------------
format: 00011100 1011SSSS S***XXXX XXXXXXXX

constant operands:
S = operation subtype  (     domain/range: 0 to 31,
                        operational range: 1 to 3)

GOOL operands:
X = PID of object with spawn state bit to read

STACK out:
O = bit read [may be inverted (0=1, 1=0) for some operation subtypes]

operation:

The upper 24 bits of an object's PID determines the index of its 'local spawn state bits' in the 
'states' array of the GOOL namespace. The operation reads a specific bit-based on operation subtype 
S-from the spawn state bits for the object specified by PID X, and based on the bit's status as set 
or clear, pushes either a 1 (set/clear) or 0 (clear/set) to the object's stack. The following table 
describes which bit is read [and whether or not it is inverted] prior to its ultimate push to the 
object's stack for each operation subtype S: 

-------------------------------------------------------------------------------------------
| subtype S = |                     read operation [incl stack push]                      |                          
-------------------------------------------------------------------------------------------
|      0      | no operation                                                              |
|      1      | pushes a 1 if the 'no respawn' bit           (bit 2) is clear/0 otherwise |
|      2      | pushes a 1 if the ?                          (bit 3) is set  /0 otherwise |
|      3      | pushes a 1 if the level transition pres. bit (bit 4) is set  /0 otherwise |
-------------------------------------------------------------------------------------------

additional:
-If X is specified as false (0xBE0), the operation will instead push a 0 to the object's stack.
-X's value must be a valid PID; if not, unpredictable behavior may ensue.
-X must not be specified as true (0xBF0); doing so will trap the system.
-If S's value is outside of the operational range, the operation will accomplish nothing.

(T = 12) type 12 - (various) level operations
---------------------------------------------
format: 00011100 1100SSSS S***XXXX XXXXXXXX

constant operands:
S = operation subtype  (     domain/range: 0 to 31,
                        operational range: 0 to 11) 

GOOL operands:
X = multi-purpose

operation:

One of 12 types of operations is performed based on operation subtype S; the following table 
describes the specific type of operation performed for each operation subtype S: 

-------------------------------------------------------------------------------------------
| subtype S = |                            level operation                                |                          
-------------------------------------------------------------------------------------------
|      0      | save level state                                                          |
|      1      | load level state                                                          |
|      2      | adopt this object to some other root group object (change category)       |
|      3      | unused; X is translated                                                   |
|      4      | ? sets field 0x28 of structure specified by X to current zone header item |
|      5      | ? sets gp[0x268] to 0xFFFFFD56                                            |
|      6      | play new level music                                                      |
|      7      | ?terminates all terminable [root group descendant]objects in neighbor zones|
|      8      | push 'look up' angle between object trans vector and vector X             |
|      9      | change level (game mode)                                                  |
|     10      | (wait for sync and?) seek disc to location of NSD file[?] for level/mode X|
|     11      | reset 'inventory' and global spawn state bit listings                     |
-------------------------------------------------------------------------------------------

TODO: listings for each operation subtype...

......incomplete

TODO
.....
-----

0x82) general control flow
--------------------------
format: 10000010 TTCCMMMM MMLLLLLL LLLLLLLL

constant operands:
T = control flow operation type  (domain/range: 0    to     3)
C = condition check type         (domain/range: 0    to     3)
M = index object field to check  (      domain: 0    to  0x3F;
                                         range: 0x60 to 0x15C, R=4N)
L = multi-purpose

operation:

Firstly, the operation determines, based on the result of a specific condition check [of type C] of 
the object field at index M, whether or not it should proceed with its intended control flow 
operation as specified by T. For any type of condition check, the boolean result of the check is 
stored in the interpreter local variable 'conditionFlag'; after the check, if 'conditionFlag' is 
true, the operation will proceed with the intended control flow operation. The following table 
lists, for each condition check type C, the corresponding conditional expressions as evaluated and 
assigned to 'conditionFlag' and equivalent descriptions of under what condition the operation will 
proceed. 

[note each expression is listed as the assignment of its evaluation to 'conditionFlag']
Where V is the value of the data in object field at index M: 
---------------------------------------------------------------------------------------------------------
| check type C = | conditional expression evaled |                 when to control flow                 |
---------------------------------------------------------------------------------------------------------
|       0        |     conditionFlag = true      |                      always                          | 
|       1        |   conditionFlag = (V != 0)    |              if V is not equal to zero               |
|       2        |   conditionFlag = (V == 0)    |                   if V equals zero                   |
|       3        |              n/a              | predetermined elsewhere (no change in conditionFlag) |
---------------------------------------------------------------------------------------------------------

In determining the value of V for check types 1 & 2:
  
  -When M = 0x1F, the operation uses the M bits as if they were the first 6 A bits in a translation of 
   GOOL [in] operand bit sequence/specification type i; thus, a value of M = 0x1F specifies that the 
   object's stack is to be popped for the value of V 

  -When M != 0x1F, the operation uses the M bits as if they were the first 6 A bits in a translation of 
   GOOL [in] operand bit sequence/specification type ii; thus, the value of V is determined from the 
   value of the object field at index M, relative to the object's process structure (i.e. field at 
   offset = 0x60 + (M * 4)). 

After the check, if 'conditionFlag' is true, the operation will proceed with the control flow 
operation as specified by operand T. The following lists and describes the specifics of each control 
flow operation by type T, including the corresponding mnemonic names for each possible format of 
instructions [of this opcode] that specify that type: 

*(T = 0) type 0 - 'branch' operation [incl stack pop]
-----------------------------------------------------
---------------------------------------------------------------------------------
| Name |               Format                |            Description           | 
---------------------------------------------------------------------------------
| B    | 10000010 0000MMMM MMPPPPLL LLLLLLLL |  -branch                         |
| BNEZ | 10000010 0001MMMM MMPPPPLL LLLLLLLL |  -branch not equal zero          |
| BEQZ | 10000010 0010MMMM MMPPPPLL LLLLLLLL |  -branch equal zero              |
| BTRU | 10000010 0011MMMM MMPPPPLL LLLLLLLL |  -branch 'conditionFlag' == true |
---------------------------------------------------------------------------------
 
constant operands:
L = branch offset                 (      domain: -0x1FF to 0x1FF 
                                          range: -0x7FF to 0x7FF) 
P = stack pop/rewind count        (domain/range: 0 to 15 (longs))
M = index of object field checked

operation:

The object's program counter is modified to point to the instruction that is at a location of L 
instructions relative to the instruction at its current location (object.process.pc += L). Thus, the 
interpreter will 'branch' or skip over the L proceeding (if positive) or go back L preceding (if 
negative) instructions for its next fetch. 

L can be specified as a negative offset with the appropriate 2's complement format: 

L = 1NNNNNNNNN (-N): B = 111111111111111111111NNNNNNNNN00 (4 * -N)  (branch backward N instructions)
L = 0NNNNNNNNN ( N): B = 000000000000000000000NNNNNNNNN00 (4 *  N)  (branch  forward N instructions) 

(where B is the signed offset, in bytes)

Also, when operand P is nonzero, in addition to the branch/program counter modification, P [count] 
longs/data units are popped off of the objects stack. Conditionally reached, nested portions of code 
may utilize branch type control instructions that specify an expected number P of longs to pop back 
the object's stack after they have been pushed as a result of operations for preceding instructions 
within that scope; their desired operation is to 'rewind' the stack, to appropriately leave the 
scope in which those longs [i.e. local variables] were created. 

additional:
-If L is 0 and P is nonzero, then the operation does not perform any 'branching'-it instead only pops 
 P longs off of the object's stack. 
-L must not be specified such that a branch to a location outside of object code results.
-P must not be specified such that a stack underflow results.

*(T = 1) type 1 - state change operation
----------------------------------------
---------------------------------------------------------------------------------------
| Name |               Format                |                Description             | 
---------------------------------------------------------------------------------------
| CST  | 10000010 0100MMMM MMSSSSSS SSSSSSSS |  -change state                         |
| CSNZ | 10000010 0101MMMM MMSSSSSS SSSSSSSS |  -change state not equal zero          |
| CSEZ | 10000010 0110MMMM MMSSSSSS SSSSSSSS |  -change state equal zero              |
| CSTT | 10000010 0110MMMM MMSSSSSS SSSSSSSS |  -change state 'conditionFlag' == true |
---------------------------------------------------------------------------------------

constant operands:
S = new state
M = index of object field checked

operation:

The operation first uses the state S as an index into the object's state definitions-or 'states' 
array of the 'GOOL_states' item [i.e. item 5] in the object's instantiating entry ('global')-to 
resolve that state's corresponding state definition [structure]. If the object has a display mode 
('displayMode') of 2, 3, or 4, and if either bit 2 or bit 13 is set in the 'flags' bitfield for that 
state, or if any of the other bits that are set in that bitfield are still set in the object's 
'statusC' field, then the following state change will not occur. If the object does not have a 
display mode of 2, 3, or 4, and if any of the bits that are set in the 'flags' bitfield for state 
definition S are still set in the object's 'statusC' field, then the following state change will not 
occur. 

If the state change shall still occur, then the operation calls the 'changeState' routine with this 
object, the new state, and 0 and 0 for 'args' and 'count' respectively, as arguments. After changing 
state, if the 'suspend on state change' bit (bit 2) of the interpreter status flags is clear or the 
state change is [un?successful] (TODO: gool error code), then the operation will complete by popping 
the 'wait' value [normally present after a state change] off of the object's stack, for 
interpretation shall continue. However, if the state change is successful and the 'suspend on state 
change' bit (bit 2) of the interpreter status flags is set, then the operation will complete by 
suspending the interpreter/returning from interpret() with the GOOL success code returned from 
'changeState'. 

additional:
n/a

*(T = 2) type 2 - return operation
----------------------------------------
---------------------------------------------------------------------------------------
| Name |               Format                |                Description             | 
---------------------------------------------------------------------------------------
| RET  | 10000010 1000MMMM MMSSSSSS SSSSSSSS |  -return to previous stack frame       |
| RNEZ | 10000010 1001MMMM MMSSSSSS SSSSSSSS |  -return .. not equal zero             |
| REQZ | 10000010 1010MMMM MMSSSSSS SSSSSSSS |  -return .. equal zero                 |
| RETT | 10000010 1010MMMM MMSSSSSS SSSSSSSS |  -return .. 'conditionFlag' == true    |
---------------------------------------------------------------------------------------

constant operands:
M = index of object field checked

operation:

The operation first checks the left short/[relative] previous frame start offset within the 
respective long [i.e. previous frame start/end (relative) address pair] of the current stack 
frame header. If this is 0, then the current frame is the initial stack frame; otherwise, the current 
frame is not the initial stack frame.

---
If the current frame is not the initial stack frame, then the operation proceeds by:
 
  i)  Restoring the previous stack frame as the current stack frame
  ii) Possibly suspending execution for certain sequences of set/cleared 
      interpreter status flags
      
    [At any instant, an object's current stack frame is defined by the N longs of data in the range of 
    locations between the object's frame pointer and stack pointer locations. The first 3 words in this
    range defines the stack frame header; these consist of preserved interpreter status flags, 
    program counter, stack, and frame pointer locations. This information is 'preserved' because it 
    consists of values or addresses present in the interpreter global variable and respective object 
    fields at a -previous- instant. If the object's current stack frame includes the addresses present
    in its frame and stack pointer at a previous instant, then these addresses define what was the 
    object's current stack frame at a previous instant-or simply the object's previous stack frame.
    At that instant, execution or interpretation would have continued with fetching the instruction 
    at the preserved program counter location had the current stack frame not been created and 
    consequently the program counter overwritten with the location of a block of code requested for
    subsequent execution, ultimately leading to the fetch of some RET instruction. Similarly, the 
    interpreter status flags would have retained their preserved value had they not been overwritten 
    such that the flow of execution starting with the fetch at the requested block behaved in a specified 
    manner. With all of this information preserved in the current stack frame, the operation of the RET 
    instruction will then -restore- the object's previous stack frame-including that of the preserved 
    program counter location and interpreter status flags-such that execution can continue as if the 
    current stack frame had never been created, with the previous stack frame restored as the current.]

First, the following steps are taken in restoring the previous stack frame as the current stack frame:

- the object's program counter is [re]set to the return location within the current frame header

- i)  the left/upper halfword of the current interpreter status flags is preserved in/
      copied over the left/upper halfword of the 'tempFlags' interpreter local variable; 
  ii) the right/lower halfword of the 'previous'/preserved status flags within the current 
      frame header is preserved in/copied over the right/lower halfword of 'tempFlags' 
    
- the object's frame pointer is [re]set to the location of the absolute address calculated from 
  the 'previous frame start' relative offset [i.e. from the previous frame start/end (relative) 
  address pair] within the current stack frame header
- the object's stack pointer is [re]set to the location of the absolute address calculated from 
  the 'previous frame end' relative offset [i.e. from the previous frame start/end (relative) 
  address pair] within the current stack frame header

Finally, the interpreter decides whether or not to suspend execution based on interpreter status:

- if not event service mode                                (bit 4 of interpreter status flags is cleared)
  - if interpreter must not suspend on return              (bit 1 of interpreter status flags is cleared)
    - restore interpreter status flags to 'tempFlags'
  - else [if interpreter must suspend on return]
    - if interpreter must not preserve status flags        (bit 5 of interpreter status flags is clearaed)
      - if preserved status flags in current frame are not
        'dummy' status flags of the initial frame (0xFFFF)
        - replace preserved status flags with 0      
    - return from interpret() with GOOL_SUCCESS code
- else [if event service mode]
  - if, at this point, interpreter musnt always return a   (bit 6 of interpreter status flags is cleared)
    null state 
    - return from interpret() with GOOL_TERMSTATE code
      and the state corresponding to serviced event
  - else [if at this point interpreter must return a null state]
    - return from interpret() with GOOL_SUCCESS code
      and a null state corresponding to no serviced event
---
If the current frame is the initial stack frame, then the operation proceeds by
simply suspending the interpreter with the appropriate return code:        

- if not event service mode                                (bit 4 of interpreter status flags is cleared)
  - return from interpret() with GOOL_ERROR code
- else [if event service mode]
  - if, at this point, interpreter musnt always return a   (bit 6 of interpreter status flags is cleared)
    null state 
    - return from interpret() with GOOL_TERMSTATE code
      and the state corresponding to serviced event
  - else [if at this point interpreter must return a null state]
    - return from interpret() with GOOL_SUCCESS code
      and a null state corresponding to no serviced event
      
      
----------------------------------------------
| bit |                flag                  |
----------------------------------------------
|  1  |  suspend on return                   |
|  2  |  suspend on state change/event issue |
|  3  |  suspend on animate                  |
|  4  |  event service mode                  |
|  5  |  preserve interpreter status flags   |
|  6  |  event service return null state     |
----------------------------------------------


INCOMPLETE


 
Unfortunately that is all the 'user-friendly' documentation I can give at this time; more 
will be released in the future. You can attempt to decipher the rest of my documentation
in the ./crashdocs subdirectory (start with README.txt).

