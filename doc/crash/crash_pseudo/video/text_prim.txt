sub_8001E7D8(obj, anim, aniFrame, primBuffer, flag){  //s1 = obj  //s0 = anim  //s2 = aniFrame  //s5 = primBuffer  //s6 = flag    //a3 = 0x26705EBF    //a0 = &obj[0x80]; trans  //a1 = &0x57888;  //a2 = obj[0xCC]; statusB        scaleX = obj[0x98]; //v1  if (scaleX < 0)     //ignore flip    scaleX = -scaleX;      //integral = HIWORD(scaleX * 0x26705EBF);  //s3 = (integral >> 12) - (scaleX >> 31);  scale = scaleX/27279;        var_88 = &0x57844;  var_84 = *(0x578D0);  var_80 = 0x3C00;  var_7C = (((obj[0xCC] >> 18) ^ 1) & 1); //bit 18 not set equates to the flag being set    retval = sub_8003A144(&obj[0x80], 0x57888, obj[0xCC] & 0x200, scale);    if (retval)  {    loc = anim + 0xC;        count = 0;    numZero = 0;    if (aniFrame > 0)    {      do      {        if (loc[count] == 0)  //lbu          numZero++;                  count++;      } while (numZero < aniFrame)    }        visMode = obj[0x128] >> 8;        codeEntry = obj[0x20];    codeAnims = codeEntry[0x24];        if (visMode == 0)      EIDoffset = anim[0x8] * 8;    else      EIDoffset = visMode * 8;          EID   = codeAnims[4 + EIDoffset];    tpage = EID_PROCESS(EID);        stack = obj[0xDC];        var_88 = stack[-0x10];    var_84 = stack[-0x14];        sub_8003D740(&var_78, count, stack[-0x8], stack[-0xC]);        str   = var_78;    strIt = var_78;        if (*(strIt++) != 0)     //if first char nonzero    {            while (*(strIt++) != 0) //if any other char is zero            strIt--;               //go back 1    }        if (strIt != str)     //if we're not at the beginning    {      strIt--;            //then if one back we're at the beginning      if (strIt != str)      {        while (*(strIt) == 0x20 &&               strIt-- != strIt);   //skip       }    }        strIt[1] = 0;   //place a 0 after the first non 0x20 char        //a b c d e f 0x20 g h i j k l becomes a b c d e f 0x20 0 h i j k l        if (flag)      arg = sub_8001E3D4(obj, str, 0, &codeAnims[EIDOffset], tpage, scale, 0);    else      arg = 0;    sub_8001E3D4(obj, str, (-arg+(-arg>>31))>>2,&codeAnims[EIDOffset], tpage, scale, primBuffer);  }}sub_8001E3D4(obj, str, val, anim, tpage, scale, prims){  //s6 = scale  //t0 = prims  //s3 = obj  //s0 = str  //fp = anim  //s7 = 0  //var_48 = val  //var_40 = 0  //var_38 = 0  //var_30 = 1    if (prims && obj[0xCC] & 0x400)  {    var_38 = obj[0xCC] & 0x400;        //v0 = 0x000F423F    //v1 = 0xFFF0BDC1        var_68 = 0x000F423F    var_64 = 0x000F423F    var_5C = 0xFFF0BDC1    var_58 = 0xFFF0BDC1  }   var_80 = var_48;      strIt = str;   while (strIt[0] != 0)  {    //s1 = 0x190    //s5 = 0x7E;    //s2 = &var_50       defFact = 0x190;       if (strIt[0] == 0x7E)    {      strIt++;               curChar = strIt[0];      strIt++;      if (curChar == 0x6E)        goto 1e5e0;      else if (curChar > 0x6F)      {        if (curChar == 0x70)          goto 1e510;        else if (curChar == 0x73)          goto 1e558; (a1 = 0);        else          goto 1e5fc with v0 = defFact << scale;      }      else if (curChar == 0x25)        goto 1e5e0;      else if (curChar == 0x63)        goto 1e4ec;      else        goto 1e5fc with v0 = defFact << scale;            1e4ec:      {        nextCharA = *(strIt++);        nextCharB = *(strIt);                var_30 = (nextCharA ^ 0x31) < 1;                if (nextCharB == 0x7E) { continue; }        else          goto 1e5fc with v0 = defFact << scale;      }            1e510:      {        nextCharA = *(strIt++);        nextCharB = *(strIt);                stackLoc = (nextCharA - 0x2E) << 2;                stackFlag = *(obj[0xDC] - stackLoc);                if (stackFlag == 1)          strIt++;        strIt++;                nextCharCD = *(strIt);                 if (nextCharCD == 0)          goto 1e734;                   if (nextCharCD == 0x7E) { continue; }        else          goto 1e5fc with v0 = defFact << scale;      }             1e558:      {        count = 0;                 nextCharA = *(strIt++);        nextCharB = *(strIt++);                if (nextCharB != 0x7E)        {          loc = var_50;                    nextChar = nextCharB;          do          {            *(loc++) = nextChar;                        count++;                        nextChar = *(strIt++);          } while (nextChar != 0x7E);        }                loc[count] = 0;                if (nextCharA == 0x78)          defFact = atoi(loc);   //s1        else          numB    = atoi(loc);   //s4                  nextChar = *(strIt);        if (nextChar == 0x7E)          continue;        else          goto 1e5fc with v0 = defFact << scale;      }              1e5e0:      {        var_80 = var_48;                        v0 = (var_8E << scale)        s7 = -v0;                goto 1e720      }    }    v0 = defFact << scale;        1e5fc:        a0 = var_80;    totScale = v0 + var_80; //a2    a2 = totScale;        nextChar = *(strIt);    offset   = (nextChar * 12) - 0x178;        var_74 = totScale;        animT = anim[offset];        v0 = (animT[0xA] << scale);        a3 = s7 - v0;    a1 = a3 - (numB << scale);        var_70 = a3;    var_7C = a1;        if (var_40 < totScale)      var_40 = totScale;          if (prims && animT[0] != 0)    {      if (var_38 != 0)      {        v1 = var_68;        if (a0 < var_68)          v1 = a0;                a0 = var_64;        if (a1 < var_64)          a0 = a1;                  var_68 = v1;                a1 = var_5C;        if (a1 < a2)          a1 = a2;                  var_64 = a0;        var_5C = a1;                v1 = var_58;        if (v1 < a3)          v1 = a3;          var_58 = v1;      }            var_8C = prims;      var_88 = var_30;      sp[0x10] = var_80;      sub_80018DBC(obj, animT, obj[0x138], tpage, &var_80, prims, var_30);    }        var_80 += animT[0x8] << scale;        1e720:        s1 = 0x190;    strIt++;  };         if (var_38 && prims && arg_25C)  {    a3 = &var_68;    a2 = tpage;        var_68 -= 0x64;    var_64 = var_64;  //no change    var_5C += 0x64;    var_58 = var_58;  // no change        sp[0x10] = prims;    sub_80018B98(&arg_25C, obj[0x138] - 0xA, tpage, &var_68);  }    return var_40;}sub_80018DBC(obj, anim, size, tpage, struct, zbuffer, val){  //t4 = struct  //t6 = prims  //t5 = val    v1 = struct[0x10];  a0 = struct[0] //lh    GTE.VXY0 = v1 << 16 | a0;  GTE.VZ0  = 0;    v0 = struct[0xC]; //lh  GTE.VXY1 = v1 << 16 | v0;  GTE.VZ1  = 0;    v0 = struct[0x4];  GTE.VXY2 = v0 << 16 | a0;  GTE.VZ2  = 0;    GTE.perspectiveTransform();    if (GTE.error) { return; }    newPrim = *(0x5840C)[0x78];  //a0   *(0x5840C)[0x78] += 0x34;    t3 = anim[0];  //lw    t1 = newPrim   if (val)  {    v1 = anim[0];  //lb    R1 = obj[0x48];    newPrim[4] = (R1 * v1) >> 8;  //sb    v1 = anim[1];  //lb    R2 = obj[0x4A];    newPrim[5] = (R2 * v1) >> 8;  //sb        v1 = anim[2]; //lb    R3 = obj[0x4C];    newPrim[6] = (R3 * v1) >> 8; //sb        v1 = anim[0];  //lb    G1 = obj[0x4E];    newPrim[0x10] = (G1 * v1) >> 8;  //sb    v1 = anim[1];  //lb    G2 = obj[0x50];    newPrim[0x11] = (G2 * v1) >> 8;  //sb        v1 = anim[2]; //lb    G3 = obj[0x52];    newPrim[0x12] = (G3 * v1) >> 8; //sb        v1 = anim[0];  //lb    B1 = obj[0x54];    newPrim[0x1C] = (B1 * v1) >> 8;  //sb    v1 = anim[1];  //lb    B2 = obj[0x56];    newPrim[0x1D] = (B2 * v1) >> 8;  //sb        v1 = anim[2]; //lb    B3 = obj[0x58];    newPrim[0x1E] = (B3 * v1) >> 8; //sb        v1 = anim[0]; //lb        RI = obj[0x5A];    newPrim[0x28] = (RI * v1) >> 8; //sb        v1 = anim[1]; //lb        GI = obj[0x5C];    newPrim[0x29] = (GI * v1) >> 8; //sb    v1 = anim[2]; //lb        BI = obj[0x5E];    newPrim[0x2A] = (BI * v1) >> 8; //sb     }  else  {    newPrim[0x4] = t3;    newPrim[0x10] = t3;    newPrim[0x1C] = t3;    newPrim[0x28] = t3;  }    flagsAdd = t3 >> 24;  semiTrans = flagsAdd & 0x60;    if (semiTrans)    primType = 0x3C;  else    primType = 0x3E;      newPrim[7] = primType;  newPrim[0x20] = GTE.SXY2;  newPrim[0x14] = GTE.SXY1;    v0 = *(0x578D0);  a0 = (size + 0x800) - (((v0 + (v0 >> 31)) >> 1);    sum = GTE.SZ1 + GTE.SZ2 + GTE.SZ3;  avg = (sum >> 5);    diff = a0 - avg;  v0 = diff;        if (diff < 0x7FF)  {    a0 = 0xFF0000;    if (v0 < 0)      v0 = 0;          offset = v0 * 4;  }  else  {    offset = 0x1FFC;  }    oldPrim    = zbuffer[offset] | 0x0C000000;  newPrim[0] = oldPrim;    zBuffer[offset] = newPrim & 0x00FFFFFF;    newPrim[0x8]  = GTE.SXY0;      v0 = struct[4];   //lw  v1 = struct[0xC]; //lh    GTE.VXY0 = v0 << 16;  GTE.VZ0  = 0;  GTE.perspectiveTransform();    newPrim[0x2C] = GTE.SXY2;  a0 = anim[4];    v0 = (a0 >> 20);  t2 = v0 & 3;    a1 = t2 << 7;    v0 = t2 + 10;  a2 = (a0 & 0x3E000) >> v0;    v0 = ((a0 & 0x1F) | (tpage & 0x80)) << 8;  t2 = a2 | v0;    newPrim[0xE] = ((tpage >> 4) & 0xFFF0) | (a0 & 0x1FC0) | (t3 & 0xF);    newPrim[0x1A] = (t3 & 0x60) | (tpage & 0x1C) | (a1) | ((a0 >> 18) & 3);    regions = 0x51774;  region = (a0 >> 22) * 8;    newPrim[0xC] = regions[region + 0] + t2;  newPrim[0x18] = (regions[region + 0] >> 16) + t2;    newPrim[0x24] = regions[region + 4] + t2;  newPrim[0x30] = (regions[region + 4] >> 16) + t2;  }          